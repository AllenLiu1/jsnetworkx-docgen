{"Algorithms":{"betweennessCentrality":{"name":"betweennessCentrality","aliases":["betweennessCentrality","algorithms.betweennessCentrality","algorithms.centrality.betweennessCentrality","algorithms.centrality.betweenness.betweennessCentrality","algorithms.betweenness.betweennessCentrality","centrality.betweennessCentrality","centrality.betweenness.betweennessCentrality","betweenness.betweennessCentrality"],"isAsync":false,"async":"genBetweennessCentrality","params":[{"name":"G","type":{"type":"NameExpression","name":"Graph","nullable":false},"typeAsHTML":"!Graph","descr":"A JSNetworkX graph"},{"name":{"name":"optArgDict"},"type":{"type":"NameExpression","name":"betweennessCentralityArgs","optional":true},"typeAsHTML":"betweennessCentralityArgs=","defaultValue":"{}"}],"description":"Compute the shortest-path betweenness centrality for nodes.\n\nBetweenness centrality of a node `v` is the sum of the\nfraction of all-pairs shortest paths that pass through `v`:\n\n```math\nc_B(v) = \\sum_{s,t \\in V} \\frac{\\sigma(s, t|v)}{\\sigma(s, t)}\n```\n\nwhere `$V$` is the set of nodes, `$\\sigma(s, t)$` is the number of\nshortest `$(s, t)$`-paths,  and `$\\sigma(s, t|v)$` is the number of those\npaths  passing through some  node `$v$` other than `$s, t$`.\nIf `$s = t$`, `$\\sigma(s, t) = 1$`, and if `$v \\in {s, t}$`,\n`$\\sigma(s, t|v) = 0$` [2]_.\n\n### Notes\n\nThe algorithm is from Ulrik Brandes [1]_.\nSee [2]_ for details on algorithms for variations and related metrics.\n\nFor approximate betweenness calculations set `k=#samples` to use\n`k` nodes (\"pivots\") to estimate the betweenness values. For an estimate\nof the number of pivots needed see [3]_.\n\nFor weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes.\n\n### References\n\n.. [1]  A Faster Algorithm for Betweenness Centrality.\n   Ulrik Brandes,\n   Journal of Mathematical Sociology 25(2):163-177, 2001.\n   http://www.inf.uni-konstanz.de/algo/publications/b-fabc-01.pdf\n.. [2] Ulrik Brandes: On Variants of Shortest-Path Betweenness\n   Centrality and their Generic Computation.\n   Social Networks 30(2):136-145, 2008.\n   http://www.inf.uni-konstanz.de/algo/publications/b-vspbc-08.pdf\n.. [3] Ulrik Brandes and Christian Pich:\n   Centrality Estimation in Large Networks.\n   International Journal of Bifurcation and Chaos 17(7):2303-2318, 2007.\n   http://www.inf.uni-konstanz.de/algo/publications/bp-celn-06.pdf","returns":{"name":"object","type":{"type":"NameExpression","name":"Map"},"typeAsHTML":"Map","descr":"with node keys with betweenness centrality as the value."}},"genBetweennessCentrality":{"name":"genBetweennessCentrality","aliases":["genBetweennessCentrality","algorithms.genBetweennessCentrality","algorithms.centrality.genBetweennessCentrality","algorithms.centrality.betweenness.genBetweennessCentrality","algorithms.betweenness.genBetweennessCentrality","centrality.genBetweennessCentrality","centrality.betweenness.genBetweennessCentrality","betweenness.genBetweennessCentrality"],"sync":"betweennessCentrality","isAsync":true},"edgeBetweennessCentrality":{"name":"edgeBetweennessCentrality","aliases":["edgeBetweennessCentrality","algorithms.edgeBetweennessCentrality","algorithms.centrality.edgeBetweennessCentrality","algorithms.centrality.betweenness.edgeBetweennessCentrality","algorithms.betweenness.edgeBetweennessCentrality","centrality.edgeBetweennessCentrality","centrality.betweenness.edgeBetweennessCentrality","betweenness.edgeBetweennessCentrality"],"isAsync":false,"async":"genEdgeBetweennessCentrality","params":[{"name":"G","type":{"type":"NameExpression","name":"Graph","nullable":false},"typeAsHTML":"!Graph","descr":"A NetworkX graph"},{"name":{"name":"optArgDict"},"type":{"type":"NameExpression","name":"edgeBetweennessCentralityArgs","optional":true},"typeAsHTML":"edgeBetweennessCentralityArgs=","descr":"(default=null)","defaultValue":"{}"}],"description":"Compute betweenness centrality for edges.\n\nBetweenness centrality of an edge `$e$` is the sum of the\nfraction of all-pairs shortest paths that pass through `$e$`:\n\n```math\nc_B(v) = \\sum_{s,t \\in V} \\frac{\\sigma(s, t|e)}{\\sigma(s, t)}\n```\n\nwhere `$V$` is the set of nodes,`$\\sigma(s, t)$` is the number of\nshortest `$(s, t)$`-paths, and `$\\sigma(s, t|e)$` is the number of\nthose paths passing through edge `$e$` [2]_.\n\n### Notes\n\nThe algorithm is from Ulrik Brandes [1]_.\n\nFor weighted graphs the edge weights must be greater than zero.\nZero edge weights can produce an infinite number of equal length\npaths between pairs of nodes.\n\n### References\n\n.. [1]  A Faster Algorithm for Betweenness Centrality. Ulrik Brandes,\n   Journal of Mathematical Sociology 25(2):163-177, 2001.\n   http://www.inf.uni-konstanz.de/algo/publications/b-fabc-01.pdf\n.. [2] Ulrik Brandes: On Variants of Shortest-Path Betweenness\n   Centrality and their Generic Computation.\n   Social Networks 30(2):136-145, 2008.\n   http://www.inf.uni-konstanz.de/algo/publications/b-vspbc-08.pdf","returns":{"name":"object","type":{"type":"NameExpression","name":"Map"},"typeAsHTML":"Map","descr":"with edge keys with betweenness centrality as the value."}},"genEdgeBetweennessCentrality":{"name":"genEdgeBetweennessCentrality","aliases":["genEdgeBetweennessCentrality","algorithms.genEdgeBetweennessCentrality","algorithms.centrality.genEdgeBetweennessCentrality","algorithms.centrality.betweenness.genEdgeBetweennessCentrality","algorithms.betweenness.genEdgeBetweennessCentrality","centrality.genEdgeBetweennessCentrality","centrality.betweenness.genEdgeBetweennessCentrality","betweenness.genEdgeBetweennessCentrality"],"sync":"edgeBetweennessCentrality","isAsync":true},"findCliques":{"name":"findCliques","aliases":["findCliques","algorithms.findCliques","algorithms.clique.findCliques","clique.findCliques"]},"genFindCliques":{"name":"genFindCliques","aliases":["genFindCliques","algorithms.genFindCliques","algorithms.clique.genFindCliques","clique.genFindCliques"]},"findCliquesRecursive":{"name":"findCliquesRecursive","aliases":["findCliquesRecursive","algorithms.findCliquesRecursive","algorithms.clique.findCliquesRecursive","clique.findCliquesRecursive"]},"genFindCliquesRecursive":{"name":"genFindCliquesRecursive","aliases":["genFindCliquesRecursive","algorithms.genFindCliquesRecursive","algorithms.clique.genFindCliquesRecursive","clique.genFindCliquesRecursive"]},"graphCliqueNumber":{"name":"graphCliqueNumber","aliases":["graphCliqueNumber","algorithms.graphCliqueNumber","algorithms.clique.graphCliqueNumber","clique.graphCliqueNumber"],"isAsync":false,"async":"genGraphCliqueNumber","params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"graph"},{"name":"optCliques","type":{"type":"NameExpression","name":"Iterable","optional":true},"typeAsHTML":"Iterable="}],"description":"Return the clique number (size of the largest clique) for G.\n\nAn optional list of cliques can be input if already computed.","returns":null},"genGraphCliqueNumber":{"name":"genGraphCliqueNumber","aliases":["genGraphCliqueNumber","algorithms.genGraphCliqueNumber","algorithms.clique.genGraphCliqueNumber","clique.genGraphCliqueNumber"],"sync":"graphCliqueNumber","isAsync":true},"graphNumberOfCliques":{"name":"graphNumberOfCliques","aliases":["graphNumberOfCliques","algorithms.graphNumberOfCliques","algorithms.clique.graphNumberOfCliques","clique.graphNumberOfCliques"],"isAsync":false,"async":"genGraphNumberOfCliques","params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"graph"},{"name":"optCliques","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable"}],"description":"Returns the number of maximal cliques in G.\n\nAn optional list of cliques can be input if already computed.","returns":{"type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number"}},"genGraphNumberOfCliques":{"name":"genGraphNumberOfCliques","aliases":["genGraphNumberOfCliques","algorithms.genGraphNumberOfCliques","algorithms.clique.genGraphNumberOfCliques","clique.genGraphNumberOfCliques"],"sync":"graphNumberOfCliques","isAsync":true},"numberOfCliques":{"name":"numberOfCliques","aliases":["numberOfCliques","algorithms.numberOfCliques","algorithms.clique.numberOfCliques","clique.numberOfCliques"],"isAsync":false,"async":"genNumberOfCliques","params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"graph"},{"name":"optNodes","type":{"type":"NameExpression","name":"NodeContainer","optional":true},"typeAsHTML":"NodeContainer=","descr":"List of nodes"},{"name":"optCliques","type":{"type":"NameExpression","name":"Iterable","optional":true},"typeAsHTML":"Iterable=","descr":"List of cliques"}],"description":"Returns the number of maximal cliques for each node.\n\nReturns a single or list depending on input nodes.\nOptional list of cliques can be input if already computed.","returns":{"type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Map"},{"type":"NameExpression","name":"number"}],"nullable":false},"typeAsHTML":"!(Map|number)"}},"genNumberOfCliques":{"name":"genNumberOfCliques","aliases":["genNumberOfCliques","algorithms.genNumberOfCliques","algorithms.clique.genNumberOfCliques","clique.genNumberOfCliques"],"sync":"numberOfCliques","isAsync":true},"triangles":{"name":"triangles","aliases":["triangles","algorithms.triangles","algorithms.cluster.triangles","cluster.triangles"],"isAsync":false,"async":"genTriangles","params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"A jsnetworkx graph"},{"name":"optNodes","type":{"type":"NameExpression","name":"NodeContainer","optional":true},"typeAsHTML":"NodeContainer=","descr":"(default: all nodes)\n     Compute triangles for nodes in this container."}],"description":"Compute the number of triangles.\n\nFinds the number of triangles that include a node as one vertex.\n\n### Examples\n\n```\nvar G = jsnx.completeGraph(5);\njsnx.triangles(G, 0);\n// 6\njsnx.triangles(G);\nMap {0: 6, 1: 6, 2: 6, 3: 6, 4: 6}\nArray.from(jsnx.triangles(G, [0,1]).values());\n// [6, 6]\n```\n\n### Notes\nWhen computing triangles for the entire graph each triangle is counted\nthree times, once at each node.  Self loops are ignored.","returns":{"name":"Number","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Map"},{"type":"NameExpression","name":"number"}],"nullable":false},"typeAsHTML":"!(Map|number)","descr":"of triangles keyed by node label."}},"genTriangles":{"name":"genTriangles","aliases":["genTriangles","algorithms.genTriangles","algorithms.cluster.genTriangles","cluster.genTriangles"],"sync":"triangles","isAsync":true},"averageClustering":{"name":"averageClustering","aliases":["averageClustering","algorithms.averageClustering","algorithms.cluster.averageClustering","cluster.averageClustering"],"isAsync":false,"async":"genAverageClustering","params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"graph"},{"name":"optNodes","type":{"type":"NameExpression","name":"NodeContainer","nullable":true},"typeAsHTML":"?NodeContainer","descr":"(default: all nodes)\n     Compute average clustering for nodes in this container."},{"name":"optWeight","type":{"type":"NameExpression","name":"string","nullable":true},"typeAsHTML":"?string","descr":"(default: null)\n     The edge attribute that holds the numerical value used as a weight.\n     If None, then each edge has weight 1."},{"name":{"name":"optCountZeros"},"type":{"type":"NameExpression","name":"boolean","optional":true,"nullable":true},"typeAsHTML":"?boolean=","descr":"(default: true)\n      If False include only the nodes with nonzero clustering in the average.","defaultValue":"true"}],"description":"Compute the average clustering coefficient for the graph G.\n\nThe clustering coefficient for the graph is the average,\n\n```math\nC = \\frac{1}{n}\\sum{v \\in G} c_v\n```\n\nwhere `n` is the number of nodes in `G`.\n\n### Example\n\n```\nvar G = jsnx.completeGraph(5);\njsnx.averageClustering(G);\n// 1\n```\n\n### Notes\nThis is a space saving routine; it might be faster\nto use the clustering function to get a list and then take the average.\n\nSelf loops are ignored.\n","returns":{"type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number"}},"genAverageClustering":{"name":"genAverageClustering","aliases":["genAverageClustering","algorithms.genAverageClustering","algorithms.cluster.genAverageClustering","cluster.genAverageClustering"],"sync":"averageClustering","isAsync":true},"clustering":{"name":"clustering","aliases":["clustering","algorithms.clustering","algorithms.cluster.clustering","cluster.clustering"],"isAsync":false,"async":"genClustering","params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"graph"},{"name":"optNodes","type":{"type":"NameExpression","name":"NodeContainer","optional":true,"nullable":true},"typeAsHTML":"?NodeContainer=","descr":"(default: all nodes)\n     Compute average clustering for nodes in this container."},{"name":"optWeight","type":{"type":"NameExpression","name":"string","optional":true,"nullable":true},"typeAsHTML":"?string=","descr":"(default: null)"}],"description":"Compute the clustering coefficient for nodes.\n\nFor unweighted graphs the clustering of each node `u`\nis the fraction of possible triangles through that node that exist,\n\n```math\nc_u = \\frac{2 T(u)}{deg(u)(deg(u)-1)}\n```\n\nwhere `T(u)` is the number of triangles through node `u` and `deg(u)` is the\ndegree of `u`.\n\nFor weighted graphs the clustering is defined\nas the geometric average of the subgraph edge weights,\n\n```math\nc_u = \\frac{1}{deg(u)(deg(u)-1)}\n      \\sum_{uv} (\\hat{w}_{uv} \\hat{w}_{uw} \\hat{w}_{vw})^{1/3}\n```\n\nThe edge weights `$\\hat{w}_{uv}$` are normalized by the maximum weight in the\nnetwork `$\\hat{w}_{uv} = w_{uv}/\\max(2)$`.\n\nThe value `$c_u$` is assigned to `0` if `$deg(u) < 2$`.\n\n### Example\n\n```\nvar G = jsnx.completeGraph(5);\njsnx.clustering(G, 0);\n// 1\njsnx.clustering(G);\n// Map {0: 1, 1: 1, 2: 1, 3: 1, 4: 1}\n```","returns":{"name":"Clustering","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"number"},{"type":"NameExpression","name":"Map"}],"nullable":false},"typeAsHTML":"!(number|Map)","descr":"coefficient at specified nodes"}},"genClustering":{"name":"genClustering","aliases":["genClustering","algorithms.genClustering","algorithms.cluster.genClustering","cluster.genClustering"],"sync":"clustering","isAsync":true},"transitivity":{"name":"transitivity","aliases":["transitivity","algorithms.transitivity","algorithms.cluster.transitivity","cluster.transitivity"],"isAsync":false,"async":"genTransitivity","params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"graph"}],"description":"Compute graph transitivity, the fraction of all possible triangles\npresent in G.\n\nPossible triangles are identified by the number of \"triads\"\n(two edges with a shared vertex).\n\nThe transitivity is\n\n```math\nT = 3\\frac{\\#triangles}{\\#triads}\n```\n\n### Example\n\n```\nvar G = jsnx.completeGraph(5);\njsnx.transitivity(G);\n// 1\n```","returns":{"name":"Transitivity","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number"}},"genTransitivity":{"name":"genTransitivity","aliases":["genTransitivity","algorithms.genTransitivity","algorithms.cluster.genTransitivity","cluster.genTransitivity"],"sync":"transitivity","isAsync":true},"squareClustering":{"name":"squareClustering","aliases":["squareClustering","algorithms.squareClustering","algorithms.cluster.squareClustering","cluster.squareClustering"],"isAsync":false,"async":"genSquareClustering","params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"graph"},{"name":"optNodes","type":{"type":"NameExpression","name":"NodeContainer"},"typeAsHTML":"NodeContainer","descr":"(default: all)\n  Compute clustering for nodes in this container."}],"description":"Compute the squares clustering coefficient for nodes.\n\nFor each node return the faction of possible sequares that exist at the node\n\n```math\nC_4(v) = \\frac{ \\sum_{u=1}^{k_v}\n\\sum_{w=u+1}^{k_v} q_v(u,w) }{ \\sum_{u=1}^{k_v}\n\\sum_{w=u+1}^{k_v} [a_v(u,w) + q_v(u,w)]}\n```\n\nwhere `$q_v(u,w)$` are the number of common neighbors of `$u$` and `$v$`\nother than `$v$` (i.e. squares), and\n`$a_v(u,w) = (k_u - (1+q_v(u,w)+\\theta_{uv}))(k_w - (1+q_v(u,w)+\\theta_{uw}))$`\nwhere `$\\theta_{uw} = 1$` if `u` and `w` are  connected and `$0$` otherwise.\n\n### Examples\n\n```\nvar G = jsnx.completeGraph(5);\njsnx.squareClustering(G, 0);\n// 1\njsnx.squareClustering(G);\n// Map {0: 1, 1: 1, 2: 1, 3: 1, 4: 1}\n```\n\n### Notes\n\nWhile `$C_3(v)$` (triangle clustering) gives the probability that\ntwo neighbors of node v are connected with each other, `$C_4(v)$` is\nthe probability that two neighbors of node v share a common\nneighbor different from v. This algorithm can be applied to both\nbipartite and unipartite networks.","returns":{"name":"A","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Map"},{"type":"NameExpression","name":"number"}],"nullable":false},"typeAsHTML":"!(Map|number)","descr":"dictionary keyed by node with the square clustering coefficient value."}},"genSquareClustering":{"name":"genSquareClustering","aliases":["genSquareClustering","algorithms.genSquareClustering","algorithms.cluster.genSquareClustering","cluster.genSquareClustering"],"sync":"squareClustering","isAsync":true},"isDirectedAcyclicGraph":{"name":"isDirectedAcyclicGraph","aliases":["isDirectedAcyclicGraph","algorithms.isDirectedAcyclicGraph","algorithms.dag.isDirectedAcyclicGraph","dag.isDirectedAcyclicGraph"],"isAsync":false,"async":"genIsDirectedAcyclicGraph","params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"A graph"}],"description":"Return true if the graph G is a directed acyclic graph (DAG) or false if not.","returns":{"name":"true","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","descr":"of G is a DAG, false otherwise"}},"genIsDirectedAcyclicGraph":{"name":"genIsDirectedAcyclicGraph","aliases":["genIsDirectedAcyclicGraph","algorithms.genIsDirectedAcyclicGraph","algorithms.dag.genIsDirectedAcyclicGraph","dag.genIsDirectedAcyclicGraph"],"sync":"isDirectedAcyclicGraph","isAsync":true},"topologicalSort":{"name":"topologicalSort","aliases":["topologicalSort","algorithms.topologicalSort","algorithms.dag.topologicalSort","dag.topologicalSort"],"isAsync":false,"async":"genTopologicalSort","params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"A directed Graph"},{"name":"optNbunch","type":{"type":"NameExpression","name":"NodeContainer","optional":true},"typeAsHTML":"NodeContainer=","descr":"Explore graph in specified order given\n   in opt_nbunch."}],"description":"Return a list of nodes in topological sort order.\n\nA topological sort is a non-unique permutation of the nodes such that an edge\nfrom u to v implies that u appears before v in the topological sort order.","returns":{"type":{"type":"NameExpression","name":"Array","nullable":false},"typeAsHTML":"!Array"}},"genTopologicalSort":{"name":"genTopologicalSort","aliases":["genTopologicalSort","algorithms.genTopologicalSort","algorithms.dag.genTopologicalSort","dag.genTopologicalSort"],"sync":"topologicalSort","isAsync":true},"topologicalSortRecursive":{"name":"topologicalSortRecursive","aliases":["topologicalSortRecursive","algorithms.topologicalSortRecursive","algorithms.dag.topologicalSortRecursive","dag.topologicalSortRecursive"],"isAsync":false,"async":"genTopologicalSortRecursive","params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"A directed Graph"},{"name":"optNbunch","type":{"type":"NameExpression","name":"NodeContainer","optional":true},"typeAsHTML":"NodeContainer=","descr":"Explore graph in spcified order given\n   in opt_nbunch."}],"description":"Return a list of nodes in topological sort order.\n\nA topological sort is a non-unique permutation of the nodes such that an edge\nfrom u to v implies that u appears before v in the topological sort order.","returns":{"type":{"type":"NameExpression","name":"Array","nullable":false},"typeAsHTML":"!Array"}},"genTopologicalSortRecursive":{"name":"genTopologicalSortRecursive","aliases":["genTopologicalSortRecursive","algorithms.genTopologicalSortRecursive","algorithms.dag.genTopologicalSortRecursive","dag.genTopologicalSortRecursive"],"sync":"topologicalSortRecursive","isAsync":true},"isAperiodic":{"name":"isAperiodic","aliases":["isAperiodic","algorithms.isAperiodic","algorithms.dag.isAperiodic","dag.isAperiodic"],"isAsync":false,"async":"genIsAperiodic","params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}],"description":"Return true if G is aperiodic.\n\nA directed graph is aperiodic if there is no integer k > 1 that\ndivides the length of every cycle in the graph.","returns":{"name":"true","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","descr":"if the graph is aperiodic false otherwise"}},"genIsAperiodic":{"name":"genIsAperiodic","aliases":["genIsAperiodic","algorithms.genIsAperiodic","algorithms.dag.genIsAperiodic","dag.genIsAperiodic"],"sync":"isAperiodic","isAsync":true},"isGraphical":{"name":"isGraphical","aliases":["isGraphical","algorithms.isGraphical","algorithms.graphical.isGraphical","graphical.isGraphical"],"isAsync":false,"async":"genIsGraphical","params":[{"name":"sequence","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","descr":"A sequence of integer node degrees."},{"name":{"name":"optMethod"},"type":{"type":"NameExpression","name":"string","optional":true},"typeAsHTML":"string=","descr":"(default: 'hh') ('eg' | 'hh')\n     The method used to validate the degree sequence.\n     \"eg\" corresponds to the Erdős-Gallai algorithm, and\n     \"hh\" to the Havel-Hakimi algorithm.","defaultValue":"'hh'"}],"description":"Returns `true` if `sequence` is a valid degree sequence.\nA degree sequence is valid if some graph can realize it.\n\n### Example\n```\nvar G = jsnx.pathGraph(4);\nvar sequence = G.degree().values();\njsnx.isValidDegreeSequence(sequence); // true\n```\n","returns":{"name":"`true`","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","descr":"if `sequence` is a valid degree sequence and `false` if not."}},"genIsGraphical":{"name":"genIsGraphical","aliases":["genIsGraphical","algorithms.genIsGraphical","algorithms.graphical.genIsGraphical","graphical.genIsGraphical"],"sync":"isGraphical","isAsync":true},"isValidDegreeSequence":{"name":"isValidDegreeSequence","aliases":["isValidDegreeSequence","algorithms.isValidDegreeSequence","algorithms.graphical.isValidDegreeSequence","graphical.isValidDegreeSequence"],"isAsync":false,"async":"genIsValidDegreeSequence","params":[{"name":"sequence"},{"name":"optMethod"}],"description":""},"genIsValidDegreeSequence":{"name":"genIsValidDegreeSequence","aliases":["genIsValidDegreeSequence","algorithms.genIsValidDegreeSequence","algorithms.graphical.genIsValidDegreeSequence","graphical.genIsValidDegreeSequence"],"sync":"isValidDegreeSequence","isAsync":true},"isValidDegreeSequenceHavelHakimi":{"name":"isValidDegreeSequenceHavelHakimi","aliases":["isValidDegreeSequenceHavelHakimi","algorithms.isValidDegreeSequenceHavelHakimi","algorithms.graphical.isValidDegreeSequenceHavelHakimi","graphical.isValidDegreeSequenceHavelHakimi"],"isAsync":false,"async":"genIsValidDegreeSequenceHavelHakimi","params":[{"name":"degreeSequence","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","descr":"A list of integers where each element specifies the degree of a node\n  in a graph."}],"description":"Returns `true` if `degreeSequence` cam be realized by a simple graph.\nThe Validation proceeds via the Havel-Hakimi theorem.\nWorst-case run time is `O(s)`, where `s` is the sum of the degree sequence.\n\nThe ZZ condition says that for the sequence `d`, if\n\n$$\n    |d| >= \\frac{(\\max(d) + \\min(d) + 1)^2}{4*\\min(d)}\n$$\n\nthen `d` is graphical.","returns":{"name":"`true`","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","descr":"if `degreeSequence` is graphical and `false` if not."}},"genIsValidDegreeSequenceHavelHakimi":{"name":"genIsValidDegreeSequenceHavelHakimi","aliases":["genIsValidDegreeSequenceHavelHakimi","algorithms.genIsValidDegreeSequenceHavelHakimi","algorithms.graphical.genIsValidDegreeSequenceHavelHakimi","graphical.genIsValidDegreeSequenceHavelHakimi"],"sync":"isValidDegreeSequenceHavelHakimi","isAsync":true},"isValidDegreeSequenceErdosGallai":{"name":"isValidDegreeSequenceErdosGallai","aliases":["isValidDegreeSequenceErdosGallai","algorithms.isValidDegreeSequenceErdosGallai","algorithms.graphical.isValidDegreeSequenceErdosGallai","graphical.isValidDegreeSequenceErdosGallai"],"isAsync":false,"async":"genIsValidDegreeSequenceErdosGallai","params":[{"name":"degreeSequence","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","descr":"A list of integers where each element specifies the degree of a node\n     in a graph."}],"description":"Returns `true` if `degreeSequence` can be realized by a simple graph.\nThe validation is done using the Erdős-Gallai theorem.\n\nThis implementation uses an equivalent form of the Erdős-Gallai criterion.\nWorst-case run time is $$O(n)$$ where $$n$$ is the length of the sequence.\n\nSpecifically, a sequence $$d$$ is graphical if and only if the sum of the\nsequence is even and for all strong indices $$k$$ in the sequence,\n\n$$\n   \\sum_{i=1}^{k} d_i \\leq k(k-1) + \\sum_{j=k+1}^{n} \\min(d_i,k)\n     = k(n-1) - ( k \\sum_{j=0}^{k-1} n_j - \\sum_{j=0}^{k-1} j n_j )\n$$\n\nA strong index $$k$$ is any index where $$d_k \\geq k$$ and the value $$n_j$$\nis the number of occurrences of $$j$$ in $$d$$. The maximal strong index is\ncalled the Durfee index.\n\nThe ZZ condition says that for the sequence $$d$$, if\n\n$$\n    |d| >= \\frac{(\\max(d) + \\min(d) + 1)^2}{4*\\min(d)}\n$$\n\nthen $$d$$ is graphical.\n","returns":{"name":"`true`","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","descr":"if `degreeSequence` is graphical and f`alse` if not."}},"genIsValidDegreeSequenceErdosGallai":{"name":"genIsValidDegreeSequenceErdosGallai","aliases":["genIsValidDegreeSequenceErdosGallai","algorithms.genIsValidDegreeSequenceErdosGallai","algorithms.graphical.genIsValidDegreeSequenceErdosGallai","graphical.genIsValidDegreeSequenceErdosGallai"],"sync":"isValidDegreeSequenceErdosGallai","isAsync":true},"couldBeIsomorphic":{"name":"couldBeIsomorphic","aliases":["couldBeIsomorphic","algorithms.couldBeIsomorphic","algorithms.isomorphism.couldBeIsomorphic","isomorphism.couldBeIsomorphic"],"isAsync":false,"async":"genCouldBeIsomorphic","params":[{"name":"G1","type":{"type":"NameExpression","name":"Graph","nullable":false},"typeAsHTML":"!Graph"},{"name":"G2","type":{"type":"NameExpression","name":"Graph","nullable":false},"typeAsHTML":"!Graph"}],"description":"Returns False if graphs are definitely not isomorphic.\nTrue does NOT guarantee isomorphism.\n\nChecks for matching degree, triangle, and number of cliques sequences.","returns":{"name":"False","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","descr":"if graphs are definitely not isomorphic."}},"genCouldBeIsomorphic":{"name":"genCouldBeIsomorphic","aliases":["genCouldBeIsomorphic","algorithms.genCouldBeIsomorphic","algorithms.isomorphism.genCouldBeIsomorphic","isomorphism.genCouldBeIsomorphic"],"sync":"couldBeIsomorphic","isAsync":true},"fastCouldBeIsomorphic":{"name":"fastCouldBeIsomorphic","aliases":["fastCouldBeIsomorphic","algorithms.fastCouldBeIsomorphic","algorithms.isomorphism.fastCouldBeIsomorphic","isomorphism.fastCouldBeIsomorphic"],"isAsync":false,"async":"genFastCouldBeIsomorphic","params":[{"name":"G1","type":{"type":"NameExpression","name":"Graph","nullable":false},"typeAsHTML":"!Graph"},{"name":"G2","type":{"type":"NameExpression","name":"Graph","nullable":false},"typeAsHTML":"!Graph"}],"description":"Returns False if graphs are definitely not isomorphic.\nTrue does NOT guarantee isomorphism.\n\nChecks for matching degree and triangle sequences.","returns":{"name":"False","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","descr":"if graphs are definitely not isomorphic."}},"genFastCouldBeIsomorphic":{"name":"genFastCouldBeIsomorphic","aliases":["genFastCouldBeIsomorphic","algorithms.genFastCouldBeIsomorphic","algorithms.isomorphism.genFastCouldBeIsomorphic","isomorphism.genFastCouldBeIsomorphic"],"sync":"fastCouldBeIsomorphic","isAsync":true},"fasterCouldBeIsomorphic":{"name":"fasterCouldBeIsomorphic","aliases":["fasterCouldBeIsomorphic","algorithms.fasterCouldBeIsomorphic","algorithms.isomorphism.fasterCouldBeIsomorphic","isomorphism.fasterCouldBeIsomorphic"],"isAsync":false,"async":"genFasterCouldBeIsomorphic","params":[{"name":"G1","type":{"type":"NameExpression","name":"Graph","nullable":false},"typeAsHTML":"!Graph"},{"name":"G2","type":{"type":"NameExpression","name":"Graph","nullable":false},"typeAsHTML":"!Graph"}],"description":"Returns False if graphs are definitely not isomorphic.\nTrue does NOT guarantee isomorphism.\n\nChecks for matching degree sequences.","returns":{"name":"False","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","descr":"if graphs are definitely not isomorphic."}},"genFasterCouldBeIsomorphic":{"name":"genFasterCouldBeIsomorphic","aliases":["genFasterCouldBeIsomorphic","algorithms.genFasterCouldBeIsomorphic","algorithms.isomorphism.genFasterCouldBeIsomorphic","isomorphism.genFasterCouldBeIsomorphic"],"sync":"fasterCouldBeIsomorphic","isAsync":true},"singleSourceShortestPathLength":{"name":"singleSourceShortestPathLength","aliases":["singleSourceShortestPathLength","algorithms.singleSourceShortestPathLength","algorithms.shortestPaths.singleSourceShortestPathLength","algorithms.shortestPaths.unweighted.singleSourceShortestPathLength","algorithms.unweighted.singleSourceShortestPathLength","shortestPaths.singleSourceShortestPathLength","shortestPaths.unweighted.singleSourceShortestPathLength","unweighted.singleSourceShortestPathLength"],"isAsync":false,"async":"genSingleSourceShortestPathLength","params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"graph"},{"name":"source","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"Starting node for path"},{"name":"optCutoff","type":{"type":"NameExpression","name":"number","optional":true},"typeAsHTML":"number=","descr":"Depth to stop the search. Only paths of length <= cutoff are returned."}],"description":"Compute the shortest path lengths from source to all reachable nodes.\n\n### Example\n\n```\nvar G = jsnx.pathGraph(5);\nvar length = jsnx.singleSourceShortestPathLength(G, 0);\nlength.get(4);\n// 4\nlength\n// Map {0: 0, 1: 1, 2: 2, 3: 3, 4: 4}\n```","returns":{"name":"Map","type":{"type":"NameExpression","name":"Map","nullable":false},"typeAsHTML":"!Map","descr":"of shortest path lengths keyed by target."}},"genSingleSourceShortestPathLength":{"name":"genSingleSourceShortestPathLength","aliases":["genSingleSourceShortestPathLength","algorithms.genSingleSourceShortestPathLength","algorithms.shortestPaths.genSingleSourceShortestPathLength","algorithms.shortestPaths.unweighted.genSingleSourceShortestPathLength","algorithms.unweighted.genSingleSourceShortestPathLength","shortestPaths.genSingleSourceShortestPathLength","shortestPaths.unweighted.genSingleSourceShortestPathLength","unweighted.genSingleSourceShortestPathLength"],"sync":"singleSourceShortestPathLength","isAsync":true},"allPairsShortestPathLength":{"name":"allPairsShortestPathLength","aliases":["allPairsShortestPathLength","algorithms.allPairsShortestPathLength","algorithms.shortestPaths.allPairsShortestPathLength","algorithms.shortestPaths.unweighted.allPairsShortestPathLength","algorithms.unweighted.allPairsShortestPathLength","shortestPaths.allPairsShortestPathLength","shortestPaths.unweighted.allPairsShortestPathLength","unweighted.allPairsShortestPathLength"],"isAsync":false,"async":"genAllPairsShortestPathLength","params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"optCutoff","type":{"type":"NameExpression","name":"number","optional":true},"typeAsHTML":"number=","descr":"depth to stop the search.\n   Only paths of length <= cutoff are returned."}],"description":"Compute the shortest path lengths between all nodes in G.\n\nThe map returned only has keys for reachable node pairs.\n\n### Example\n\n```\nvar G = jsnx.pathGraph(5);\nvar length = jsnx.allPairsShortestPathLength(G);\nlength.get(1).get(4);\n// 3\nlength.get(1);\n// Map {0: 1, 1: 0, 2: 1, 3: 2, 4: 3}\n```","returns":{"type":{"type":"NameExpression","name":"Map","nullable":false},"typeAsHTML":"!Map"}},"genAllPairsShortestPathLength":{"name":"genAllPairsShortestPathLength","aliases":["genAllPairsShortestPathLength","algorithms.genAllPairsShortestPathLength","algorithms.shortestPaths.genAllPairsShortestPathLength","algorithms.shortestPaths.unweighted.genAllPairsShortestPathLength","algorithms.unweighted.genAllPairsShortestPathLength","shortestPaths.genAllPairsShortestPathLength","shortestPaths.unweighted.genAllPairsShortestPathLength","unweighted.genAllPairsShortestPathLength"],"sync":"allPairsShortestPathLength","isAsync":true},"bidirectionalShortestPath":{"name":"bidirectionalShortestPath","aliases":["bidirectionalShortestPath","algorithms.bidirectionalShortestPath","algorithms.shortestPaths.bidirectionalShortestPath","algorithms.shortestPaths.unweighted.bidirectionalShortestPath","algorithms.unweighted.bidirectionalShortestPath","shortestPaths.bidirectionalShortestPath","shortestPaths.unweighted.bidirectionalShortestPath","unweighted.bidirectionalShortestPath"],"isAsync":false,"async":"genBidirectionalShortestPath","params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"source","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"starting node for path"},{"name":"target","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"ending node for path"}],"description":"Return a list of nodes in a shortest path between source and target.\n\nThis algorithm is used by `shortestPath(G, source, target)`.","returns":{"type":{"type":"NameExpression","name":"Array","nullable":false},"typeAsHTML":"!Array"}},"genBidirectionalShortestPath":{"name":"genBidirectionalShortestPath","aliases":["genBidirectionalShortestPath","algorithms.genBidirectionalShortestPath","algorithms.shortestPaths.genBidirectionalShortestPath","algorithms.shortestPaths.unweighted.genBidirectionalShortestPath","algorithms.unweighted.genBidirectionalShortestPath","shortestPaths.genBidirectionalShortestPath","shortestPaths.unweighted.genBidirectionalShortestPath","unweighted.genBidirectionalShortestPath"],"sync":"bidirectionalShortestPath","isAsync":true},"singleSourceShortestPath":{"name":"singleSourceShortestPath","aliases":["singleSourceShortestPath","algorithms.singleSourceShortestPath","algorithms.shortestPaths.singleSourceShortestPath","algorithms.shortestPaths.unweighted.singleSourceShortestPath","algorithms.unweighted.singleSourceShortestPath","shortestPaths.singleSourceShortestPath","shortestPaths.unweighted.singleSourceShortestPath","unweighted.singleSourceShortestPath"],"isAsync":false,"async":"genSingleSourceShortestPath","params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"source","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node"},{"name":"optCutoff","type":{"type":"NameExpression","name":"number","optional":true},"typeAsHTML":"number=","descr":"Depth to stop the search.\n   Only paths of length <= cutoff are returned."}],"description":"Compute shortest path between source and all other nodes reachable from\nsource.\n\n### Note\nThe shortest path is not necessarily unique. So there can be multiple⋅\npaths between the source and each target node, all of which have the⋅\nsame 'shortest' length. For each target node, this function returns⋅\nonly one of those paths.\n\n### Example\n\n```\nvar G = jsnx.pathGraph(5);\nvar path = jsnx.singleSourceShortestPath(G, 0);\npath.get(4);\n// [1, 2, 3, 4]\n```","returns":{"name":"Map,","type":{"type":"TypeApplication","expression":{"type":"NameExpression","name":"Map"},"applications":[{"type":"NameExpression","name":"Array"}],"nullable":false},"typeAsHTML":"!Map.&lt;Array>","descr":"keyed by target, of shortest paths."}},"genSingleSourceShortestPath":{"name":"genSingleSourceShortestPath","aliases":["genSingleSourceShortestPath","algorithms.genSingleSourceShortestPath","algorithms.shortestPaths.genSingleSourceShortestPath","algorithms.shortestPaths.unweighted.genSingleSourceShortestPath","algorithms.unweighted.genSingleSourceShortestPath","shortestPaths.genSingleSourceShortestPath","shortestPaths.unweighted.genSingleSourceShortestPath","unweighted.genSingleSourceShortestPath"],"sync":"singleSourceShortestPath","isAsync":true},"allPairsShortestPath":{"name":"allPairsShortestPath","aliases":["allPairsShortestPath","algorithms.allPairsShortestPath","algorithms.shortestPaths.allPairsShortestPath","algorithms.shortestPaths.unweighted.allPairsShortestPath","algorithms.unweighted.allPairsShortestPath","shortestPaths.allPairsShortestPath","shortestPaths.unweighted.allPairsShortestPath","unweighted.allPairsShortestPath"],"isAsync":false,"async":"genAllPairsShortestPath","params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"optCutoff","type":{"type":"NameExpression","name":"number","optional":true},"typeAsHTML":"number=","descr":"Depth to stop the search.\n   Only paths of length <= cutoff are returned."}],"description":"Compute shortest paths between all nodes.\n\n### Example\n\n```\nvar G = jsnx.pathGraph(5);\nvar path = jsnx.allPairsShortestPath(G);\npath.get(0).get(4);\n// [0, 1, 2, 3, 4]\n```","returns":{"name":"Map,","type":{"type":"NameExpression","name":"Map","nullable":false},"typeAsHTML":"!Map","descr":"keyed by source and target, of shortest paths."}},"genAllPairsShortestPath":{"name":"genAllPairsShortestPath","aliases":["genAllPairsShortestPath","algorithms.genAllPairsShortestPath","algorithms.shortestPaths.genAllPairsShortestPath","algorithms.shortestPaths.unweighted.genAllPairsShortestPath","algorithms.unweighted.genAllPairsShortestPath","shortestPaths.genAllPairsShortestPath","shortestPaths.unweighted.genAllPairsShortestPath","unweighted.genAllPairsShortestPath"],"sync":"allPairsShortestPath","isAsync":true},"predecessor":{"name":"predecessor","aliases":["predecessor","algorithms.predecessor","algorithms.shortestPaths.predecessor","algorithms.shortestPaths.unweighted.predecessor","algorithms.unweighted.predecessor","shortestPaths.predecessor","shortestPaths.unweighted.predecessor","unweighted.predecessor"],"isAsync":false,"async":"genPredecessor","params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"},{"name":"source","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"Starting node for path"},{"name":{"name":"optArgs"},"type":{"type":"RecordType","fields":[{"type":"FieldType","key":{"type":"NameExpression","name":"target"},"value":{"type":"NameExpression","name":"Node"}},{"type":"FieldType","key":{"type":"NameExpression","name":"cutoff"},"value":{"type":"NameExpression","name":"number"}},{"type":"FieldType","key":{"type":"NameExpression","name":"returnSeen"},"value":{"type":"NameExpression","name":"boolean"}}]},"typeAsHTML":"{target: Node, cutoff: number, returnSeen: boolean}","descr":"target: If provided only predecessors between⋅source and target are\n          returned\n  cutoff: Depth to stop the search. Only paths of length <= cutoff are\n         returned","defaultValue":"{}"}],"description":"Returns a map of predecessors for the path from source to all nodes in G.\n\n### Example\n\n```\nvar G = jsnx.pathGraph(4);\nG.nodes();\n// [0, 1, 2, 3, 4]\njsnx.predecessor(G, 0);\n// Map {0: [], 1: [0], 2: [1], 3: [2]}","returns":{"name":"Map,","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Map"},{"type":"NameExpression","name":"Array"}],"nullable":false},"typeAsHTML":"!(Map|Array)","descr":"keyed by node, of predecessors in the shortest\n  path."}},"genPredecessor":{"name":"genPredecessor","aliases":["genPredecessor","algorithms.genPredecessor","algorithms.shortestPaths.genPredecessor","algorithms.shortestPaths.unweighted.genPredecessor","algorithms.unweighted.genPredecessor","shortestPaths.genPredecessor","shortestPaths.unweighted.genPredecessor","unweighted.genPredecessor"],"sync":"predecessor","isAsync":true}},"Generators":{"fullRaryTree":{"name":"fullRaryTree","aliases":["fullRaryTree","generators.fullRaryTree","generators.classic.fullRaryTree","classic.fullRaryTree"],"isAsync":false,"params":[{"name":"r","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","descr":"branching factor of the tree"},{"name":"n","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","descr":"number of nodes in the tree"},{"name":"optCreateUsing","type":{"type":"NameExpression","name":"Graph","optional":true},"typeAsHTML":"Graph=","descr":"Use specified type to construct graph"}],"description":"Creates a full r-ary tree of n vertices.\nSometimes called a k-ary, n-ary, or m-ary tree.  \"... all non-leaf\nvertices have exactly r children and all levels are full except\nfor some rightmost position of the bottom level (if a leaf at the\nbottom level is missing, then so are all of the leaves to its\nright.\"","returns":{"name":"An","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"r-ary tree with n nodes."}},"balancedTree":{"name":"balancedTree","aliases":["balancedTree","generators.balancedTree","generators.classic.balancedTree","classic.balancedTree"],"isAsync":false,"params":[{"name":"r","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","descr":"Branching factor of the tree"},{"name":"h","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","descr":"Height of the tree"},{"name":"optCreateUsing","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"Use specified type to construct graph"}],"description":"Return the perfectly balanced r-tree of height h.\n\nThis is the rooted tree where all leaves are at distance h from\nthe root. The root has degree r and all other internal nodes have\ndegree r+1.\n\nNode labels are the integers 0 (the root) up to  numberOfNodes - 1.\n\nAlso refered to as a complete r-ary tree.","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}},"completeGraph":{"name":"completeGraph","aliases":["completeGraph","generators.completeGraph","generators.classic.completeGraph","classic.completeGraph"],"isAsync":false,"params":[{"name":"n","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","descr":"The number of nodes to add to the graph"},{"name":"optCreateUsing","type":{"type":"NameExpression","name":"Graph","optional":true},"typeAsHTML":"Graph=","descr":"Graph instance to empty and add nodes to."}],"description":"Return the complete graph `$K_n$ with n nodes.\n\nNode labels are the integers 0 to n-1.","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}},"cycleGraph":{"name":"cycleGraph","aliases":["cycleGraph","generators.cycleGraph","generators.classic.cycleGraph","classic.cycleGraph"],"isAsync":false,"params":[{"name":"n","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","descr":"The number of nodes to add to the graph"},{"name":"optCreateUsing","type":{"type":"NameExpression","name":"Graph","optional":true},"typeAsHTML":"Graph=","descr":"Graph instance to empty and add nodes to."}],"description":"Return the cycle graph C_n over n nodes.\n\nC_n is the n-path with two end-nodes connected.\n\nNode labels are the integers 0 to n-1\nIf create_using is a DiGraph, the direction is in increasing order.","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}},"emptyGraph":{"name":"emptyGraph","aliases":["emptyGraph","generators.emptyGraph","generators.classic.emptyGraph","classic.emptyGraph"],"isAsync":false,"params":[{"name":"optN"},{"name":"optCreateUsing"}],"description":"Return the empty graph with n nodes and zero edges.\n\nNode labels are the integers 0 to n-1\n\n### Example\n\n```\nvar G = jsnx.emptyGraph(10)\nG.numberOfNodes()\n// 10\nG.numberOfEdges()\n// 0\n```\n\nThe variable create_using should point to a \"graph\"-like object that\nwill be cleaned (nodes and edges will be removed) and refitted as\nan empty \"graph\" with n nodes with integer labels. This capability\nis useful for specifying the class-nature of the resulting empty\n\"graph\" (i.e. Graph, DiGraph, MyWeirdGraphClass, etc.).\n\nThe variable create_using has two main uses:\nFirstly, the variable create_using can be used to create an\nempty digraph, network,etc.  For example,\n\n```\nvar n = 10\nvar G = jsnx.emptyGraph(n, jsnx.DiGraph())\n```\n\nwill create an empty digraph on n nodes.\n\nSecondly, one can pass an existing graph (digraph, pseudograph,\netc.) via create_using. For example, if G is an existing graph\n(resp. digraph, pseudograph, etc.), then empty_graph(n,G)\nwill empty G (i.e. delete all nodes and edges using G.clear() in\nbase) and then add n nodes and zero edges, and return the modified\ngraph (resp. digraph, pseudograph, etc.).","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}},"grid2dGraph":{"name":"grid2dGraph","aliases":["grid2dGraph","generators.grid2dGraph","generators.classic.grid2dGraph","classic.grid2dGraph"],"isAsync":false,"params":[{"name":"rows","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","descr":"Number of rows"},{"name":"columns","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","descr":"Number of columns"},{"name":"optPeriodic","type":{"type":"NameExpression","name":"boolean","optional":true},"typeAsHTML":"boolean="},{"name":"optCreateUsing","type":{"type":"NameExpression","name":"Graph","optional":true},"typeAsHTML":"Graph="}],"description":"Return the 2d grid graph of mxn nodes,\neach connected to its nearest neighbors.\nOptional argument periodic=True will connect\nboundary nodes via periodic boundary conditions.","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}},"nullGraph":{"name":"nullGraph","aliases":["nullGraph","generators.nullGraph","generators.classic.nullGraph","classic.nullGraph"],"isAsync":false,"params":[{"name":"optCreateUsing","type":{"type":"NameExpression","name":"Graph","optional":true},"typeAsHTML":"Graph=","descr":"Graph instance to empty and add nodes to."}],"description":"Return the Null graph with no nodes or edges.\n\nSee `emptyGraph` for the use of `optCreateUsing`.","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}},"pathGraph":{"name":"pathGraph","aliases":["pathGraph","generators.pathGraph","generators.classic.pathGraph","classic.pathGraph"],"isAsync":false,"params":[{"name":"n","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","descr":"The number of nodes to add to the graph"},{"name":"optCreateUsing","type":{"type":"NameExpression","name":"Graph","optional":true},"typeAsHTML":"Graph=","descr":"Graph instance to empty and\n     add nodes to."}],"description":"Return the Null graph with no nodes or edges.\n\nSee `emptyGraph` for the use of `optCreateUsing`.","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}},"trivialGraph":{"name":"trivialGraph","aliases":["trivialGraph","generators.trivialGraph","generators.classic.trivialGraph","classic.trivialGraph"],"isAsync":false,"params":[{"name":"optCreateUsing"}],"description":"Return the Trivial graph with one node (with integer label 0) and no edges.","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}},"havelHakimiGraph":{"name":"havelHakimiGraph","aliases":["havelHakimiGraph","generators.havelHakimiGraph","generators.degreeSequence.havelHakimiGraph","degreeSequence.havelHakimiGraph"],"isAsync":false,"async":"genHavelHakimiGraph","params":[{"name":"degreeSequence","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","descr":"list of integers\n     Each integer corresponds to the degree of a node (need not be sorted)."},{"name":"optCreateUsing","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"Return graph of this type. The instance will be cleared.\n     Directed graphs are not allowed."}],"description":"Return a simple graph with given degree sequence constructed\nusing the Havel-Hakimi algorithm.\n\n### Notes\n\nThe Havel-Hakimi algorithm constructs a simple graph by\nsuccessively connecting the node of highest degree to other nodes\nof highest degree, resorting remaining nodes by degree, and\nrepeating the process. The resulting graph has a high\ndegree-associativity. Nodes are labeled 1,.., len(degreeSequence),\ncorresponding to their position in `degreeSequence`.\n\nThe basic algorithm is from Hakimi [1] and was generalized by\nKleitman and Wang [2].\n\n### References\n\n[1] Hakimi S.,\n  On Realizability of a Set of Integers as Degrees of the\n  Vertices of a linear Graph. I,\n  Journal of SIAM, 10(3), pp. 496-506 (1962)\n[2] Kleitman D.J. and Wang D.L.\n  Algorithms for Constructing Graphs and Digraphs with Given Valences and\n  Factors,\n  Discrete Mathematics, 6(1), pp. 79-88 (1973)","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}},"genHavelHakimiGraph":{"name":"genHavelHakimiGraph","aliases":["genHavelHakimiGraph","generators.genHavelHakimiGraph","generators.degreeSequence.genHavelHakimiGraph","degreeSequence.genHavelHakimiGraph"],"sync":"havelHakimiGraph","isAsync":true},"fastGnpRandomGraph":{"name":"fastGnpRandomGraph","aliases":["fastGnpRandomGraph","generators.fastGnpRandomGraph","generators.randomGraphs.fastGnpRandomGraph","randomGraphs.fastGnpRandomGraph"],"isAsync":false,"async":"genFastGnpRandomGraph","params":[{"name":"n","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","descr":"The number of nodes"},{"name":"p","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","descr":"Probability for edge creation"},{"name":{"name":"optDirected"},"type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","descr":"(default=false) If true return a directed graph","defaultValue":"false"}],"description":"Return a random graph G_{n,p} (Erdős-Rényi graph, binomial graph).\n\nThe G_{n,p} graph algorithm chooses each of the `[n(n-1)]/2`\n(undirected) or `n(n-1)` (directed) possible edges with probability `p`.\n\nThis algorithm is `O(n+m)` where `m` is the expected number of\nedges `m = p*n*(n-1)/2`.\n\nIt should be faster than `gnpRandomGraph` when `p is small and\nthe expected number of edges is small (sparse graph).","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}},"genFastGnpRandomGraph":{"name":"genFastGnpRandomGraph","aliases":["genFastGnpRandomGraph","generators.genFastGnpRandomGraph","generators.randomGraphs.genFastGnpRandomGraph","randomGraphs.genFastGnpRandomGraph"],"sync":"fastGnpRandomGraph","isAsync":true},"gnpRandomGraph":{"name":"gnpRandomGraph","aliases":["gnpRandomGraph","generators.gnpRandomGraph","generators.randomGraphs.gnpRandomGraph","randomGraphs.gnpRandomGraph"],"isAsync":false,"async":"genGnpRandomGraph","params":[{"name":"n","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","descr":"The number of nodes"},{"name":"p","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","descr":"Probability for edge creation"},{"name":"optDirected","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","descr":"(default=false)\n If true returns a directed graph"}],"description":"Return a random graph G_{n,p} (Erdős-Rényi graph, binomial graph).\n\nChooses each of the possible edges with probability `p.\n\nThis is also called `binomialGraph` and `erdosRenyiGraph`.\n\nThis is an `O(n^2)` algorithm.  For sparse graphs (small `p`) see\n`fastGnpRandomGraph for a faster algorithm.","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}},"genGnpRandomGraph":{"name":"genGnpRandomGraph","aliases":["genGnpRandomGraph","generators.genGnpRandomGraph","generators.randomGraphs.genGnpRandomGraph","randomGraphs.genGnpRandomGraph"],"sync":"gnpRandomGraph","isAsync":true},"binomialGraph":{"name":"binomialGraph","aliases":["binomialGraph","generators.binomialGraph","generators.randomGraphs.binomialGraph","randomGraphs.binomialGraph"],"isAsync":false,"async":"genBinomialGraph","params":[{"name":"n"},{"name":"p"},{"name":"optDirected"}],"description":""},"genBinomialGraph":{"name":"genBinomialGraph","aliases":["genBinomialGraph","generators.genBinomialGraph","generators.randomGraphs.genBinomialGraph","randomGraphs.genBinomialGraph"],"sync":"binomialGraph","isAsync":true},"erdosRenyiGraph":{"name":"erdosRenyiGraph","aliases":["erdosRenyiGraph","generators.erdosRenyiGraph","generators.randomGraphs.erdosRenyiGraph","randomGraphs.erdosRenyiGraph"],"isAsync":false,"async":"genErdosRenyiGraph","params":[{"name":"n"},{"name":"p"},{"name":"optDirected"}],"description":""},"genErdosRenyiGraph":{"name":"genErdosRenyiGraph","aliases":["genErdosRenyiGraph","generators.genErdosRenyiGraph","generators.randomGraphs.genErdosRenyiGraph","randomGraphs.genErdosRenyiGraph"],"sync":"erdosRenyiGraph","isAsync":true},"makeSmallUndirectedGraph":{"name":"makeSmallUndirectedGraph","aliases":["makeSmallUndirectedGraph","generators.makeSmallUndirectedGraph","generators.small.makeSmallUndirectedGraph","small.makeSmallUndirectedGraph"],"isAsync":false,"params":[{"name":"graphDescription","type":{"type":"NameExpression","name":"Array"},"typeAsHTML":"Array","descr":"Description of the graph to create in the form `{type, name, n, list}`."},{"name":"optCreateUsing","type":{"type":"NameExpression","name":"Graph","optional":true},"typeAsHTML":"Graph=","descr":"Graph instance to empty and add nodes to."}],"description":"Return a small undirected graph described by graph_description.","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}},"makeSmallGraph":{"name":"makeSmallGraph","aliases":["makeSmallGraph","generators.makeSmallGraph","generators.small.makeSmallGraph","small.makeSmallGraph"],"isAsync":false,"params":[{"name":"graphDescription","type":{"type":"NameExpression","name":"Array"},"typeAsHTML":"Array","descr":"Description of the graph to create in the form `{type, name, n, list}`."},{"name":"optCreateUsing","type":{"type":"NameExpression","name":"Graph","optional":true},"typeAsHTML":"Graph=","descr":"Graph instance to empty and add nodes to."}],"description":"Return the small graph described by graph_description.\n\ngraphDescription is a list of the form `{type, name, n, list}`.\n\nHere `ltype` is one of `\"adjacencylist\"` or `\"edgelist\"`,\n`name` is the name of the graph and `n` the number of nodes.\nThis constructs a graph of `n` nodes with integer labels 0,..,n-1.\n\nIf `ltype=\"adjacencylist\"` then `xlist` is an adjacency list\nwith exactly `n` entries, in with the `j`'th entry (which can be empty)\nspecifies the nodes connected to vertex `j`.\n\nE.g. the \"square\" graph `$C_4$` can be obtained by\n\n```\nvar G = makeSmallGraph({\n  type: \"adjacencylist\",\n  name: \"C_4\",\n  n: 4,\n  list: [[2,4],[1,3],[2,4],[1,3]]\n});\n```\n\nor, since we do not need to add edges twice,\n\n```\nvar G = makeSmallGraph({\n  type: \"adjacencylist\",\n  name: \"C_4\",\n  n: 4,\n  list: [[2,4],[3],[4],[]]]\n});\n\nIf `ltype=\"edgelist\"` then `xlist` is an edge list written as\n`[[v1,w2],[v2,w2],...,[vk,wk]]`, where `vj` and `wj` integers in the range\n1,..,n\n\nE.g. the \"square\" graph `$C_4$` can be obtained by\n\n```\nvar G = makeSmallGraph({\n  type: \"edgelist\",\n  name: \"C_4\",\n  n: 4,\n  list: [[1,2],[3,4],[2,3],[4,1]]]\n});\n```\n\nUse the optCreateUsing argument to choose the graph class/type.","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}},"bullGraph":{"name":"bullGraph","aliases":["bullGraph","generators.bullGraph","generators.small.bullGraph","small.bullGraph"],"isAsync":false,"params":[{"name":"optCreateUsing","type":{"type":"NameExpression","name":"Graph","optional":true},"typeAsHTML":"Graph=","descr":"Graph instance to empty and add nodes to."}],"description":"Return the Bull graph.","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}},"krackhardtKiteGraph":{"name":"krackhardtKiteGraph","aliases":["krackhardtKiteGraph","generators.krackhardtKiteGraph","generators.small.krackhardtKiteGraph","small.krackhardtKiteGraph"],"isAsync":false,"params":[{"name":"optCreateUsing","type":{"type":"NameExpression","name":"Graph","optional":true},"typeAsHTML":"Graph=","descr":"Graph instance to empty and add nodes to."}],"description":"Return the Krackhardt Kite Social Network.\n\nA 10 actor social network introduced by David Krackhardt\nto illustrate: degree, betweenness, centrality, closeness, etc.\nThe traditional labeling is:\nAndre=1, Beverley=2, Carol=3, Diane=4,\nEd=5, Fernando=6, Garth=7, Heather=8, Ike=9, Jane=10.","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}},"karateClubGraph":{"name":"karateClubGraph","aliases":["karateClubGraph","generators.karateClubGraph","generators.social.karateClubGraph","social.karateClubGraph"],"isAsync":false,"params":[],"description":"Return Zachary's Karate club graph.","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}},"davisSouthernWomenGraph":{"name":"davisSouthernWomenGraph","aliases":["davisSouthernWomenGraph","generators.davisSouthernWomenGraph","generators.social.davisSouthernWomenGraph","social.davisSouthernWomenGraph"],"isAsync":false,"params":[],"description":"Return Davis Saouthern women social network.\n\nThis is a bipartite graph.","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}},"florentineFamiliesGraph":{"name":"florentineFamiliesGraph","aliases":["florentineFamiliesGraph","generators.florentineFamiliesGraph","generators.social.florentineFamiliesGraph","social.florentineFamiliesGraph"],"isAsync":false,"params":[],"description":"Return Florentine families graph.","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}}},"Classes":{"Map":{"aliases":["Map"],"isClass":true,"methods":[{"name":"get","computed":false,"isAsync":false,"params":[{"name":"key","type":{"type":"AllLiteral"},"typeAsHTML":"*"},{"name":"optDefaultValue","type":{"type":"AllLiteral","optional":true},"typeAsHTML":"*="}],"description":"Returns the value for the given key.\n\nUnlike native ES6 maps, this also accepts a default value which is returned\nif the map does not contain the value.","returns":{"type":{"type":"AllLiteral"},"typeAsHTML":"*"}},{"name":"has","computed":false,"isAsync":false,"params":[{"name":"key","type":{"type":"AllLiteral"},"typeAsHTML":"*"}],"description":"Returns true if the key is in the map.","returns":{"type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean"}},{"name":"set","computed":false,"isAsync":false,"params":[{"name":"key","type":{"type":"AllLiteral"},"typeAsHTML":"*"},{"name":"value","type":{"type":"AllLiteral"},"typeAsHTML":"*"}],"description":"Adds the value and key to the map.","returns":{"name":"the","type":{"type":"NameExpression","name":"Map"},"typeAsHTML":"Map","descr":"map object itself"}},{"name":"delete","computed":false,"isAsync":false,"params":[{"name":"key","type":{"type":"AllLiteral"},"typeAsHTML":"*"}],"description":"Remove value with given key.","returns":{"type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean"}},{"name":"entries","computed":false,"isAsync":false,"params":[],"description":"Returns an array of (key, value) tuples.","returns":{"type":{"type":"NameExpression","name":"Iterator","nullable":false},"typeAsHTML":"!Iterator"}},{"name":"keys","computed":false,"isAsync":false,"params":[],"description":"Returns an iterator over keys.","returns":{"type":{"type":"NameExpression","name":"Iterator","nullable":false},"typeAsHTML":"!Iterator"}},{"name":"values","computed":false,"isAsync":false,"params":[],"description":"Returns an array of values.","returns":{"type":{"type":"NameExpression","name":"Array","nullable":false},"typeAsHTML":"!Array"}},{"name":"clear","computed":false,"isAsync":false,"params":[],"description":"Empties the map."},{"name":"forEach","computed":false,"isAsync":false,"params":[{"name":"callback","type":{"type":"FunctionType","params":[{"type":"AllLiteral"},{"type":"AllLiteral"}]},"typeAsHTML":"function(*, *)","descr":"A function which gets the key as first\n argument and value as second argument."},{"name":"optThis","type":{"type":"AllLiteral","optional":true},"typeAsHTML":"*=","descr":"Object/value to set this to inside the callback"}],"description":"Executes the provided callback for each item in the map."},{"name":"Symbol.iterator","computed":true,"isAsync":false,"params":[],"description":"Returns an iterator for the map object.","returns":{"type":{"type":"NameExpression","name":"Iterator"},"typeAsHTML":"Iterator"}}],"properties":[{"name":"size","computed":false,"isAsync":false,"params":[],"description":"Returns the number of element in the map.","returns":{"type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number"},"readonly":false}],"staticMethods":[],"staticProperties":[],"constructor":{"name":"Map","computed":false,"isAsync":false,"params":[{"name":"optData","type":{"type":"NameExpression","name":"Iterable","optional":true},"typeAsHTML":"Iterable=","descr":"An object, array or iterator to\n populate the map with. If 'data' is an array or iterable, each element is\n expected to be a 2-tuple. The first element will be the key and second the\n value.\n If it is an object, the property names will be the keys and the value the\n values."}],"description":""}},"Set":{"aliases":["Set"],"isClass":true,"methods":[{"name":"has","computed":false,"isAsync":false,"params":[{"name":"value","type":{"type":"AllLiteral"},"typeAsHTML":"*"}],"description":"Returns true if the key is in the map.","returns":{"type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean"}},{"name":"add","computed":false,"isAsync":false,"params":[{"name":"value","type":{"type":"AllLiteral"},"typeAsHTML":"*"}],"description":"Adds the value and key to the map."},{"name":"delete","computed":false,"isAsync":false,"params":[{"name":"value","type":{"type":"AllLiteral"},"typeAsHTML":"*"}],"description":"Remove value with given key."},{"name":"values","computed":false,"isAsync":false,"params":[],"description":"Returns an array of values.","returns":{"type":{"type":"NameExpression","name":"Iterator","nullable":false},"typeAsHTML":"!Iterator"}},{"name":"keys","computed":false,"isAsync":false,"params":[],"description":"Returns an array of values.","returns":{"type":{"type":"NameExpression","name":"Iterator","nullable":false},"typeAsHTML":"!Iterator"}},{"name":"entries","computed":false,"isAsync":false,"params":[],"description":"Returns an array of values.","returns":{"type":{"type":"NameExpression","name":"Iterator","nullable":false},"typeAsHTML":"!Iterator"}},{"name":"clear","computed":false,"isAsync":false,"params":[],"description":"Empties the set."},{"name":"forEach","computed":false,"isAsync":false,"params":[{"name":"callback","type":{"type":"FunctionType","params":[{"type":"AllLiteral"}]},"typeAsHTML":"function(*)","descr":"A function which gets the key as first\n argument and value as second argument."},{"name":"optThis","type":{"type":"AllLiteral","optional":true},"typeAsHTML":"*=","descr":"Object/value to set this to inside the callback"}],"description":"Executes the provided callback for each item in the set."},{"name":"difference","computed":false,"isAsync":false,"params":[{"name":"others","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Set"},{"type":"NameExpression","name":"Array"}],"repeatable":true},"typeAsHTML":"...(Set|Array)"}],"description":"Returns a new set with the values of this set, not found in the other\nsets."},{"name":"intersection","computed":false,"isAsync":false,"params":[{"name":"others","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Set"},{"type":"NameExpression","name":"Array"}],"repeatable":true},"typeAsHTML":"...(Set|Array)"}],"description":"Returns a new set containing only elements found in this and every\nother set/array."},{"name":"pop","computed":false,"isAsync":false,"params":[],"description":"Removes and returns an element from the set.","returns":{"type":{"type":"UnknownLiteral"},"typeAsHTML":"?"}},{"name":"Symbol.iterator","computed":true,"isAsync":false,"params":[],"description":"Returns an iterator for the set object.","returns":{"type":{"type":"NameExpression","name":"Iterator"},"typeAsHTML":"Iterator"}}],"properties":[{"name":"size","computed":false,"isAsync":false,"params":[],"description":"Returns the number of element in the set.","returns":{"type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number"},"readonly":false}],"staticMethods":[],"staticProperties":[],"constructor":{"name":"Set","computed":false,"isAsync":false,"params":[{"name":"optData","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","descr":"An object, array or iterator to populate the set\nwith."}],"description":""}},"Graph":{"name":"Graph","aliases":["Graph","classes.Graph"],"isClass":true,"description":"Base class for undirected graphs.\n\nA Graph stores nodes and edges with optional data, or attributes.\n\nGraphs hold undirected edges.  Self loops are allowed but multiple\n(parallel) edges are not.\n\nNodes can be arbitrary (hashable) Python objects with optional\nkey/value attributes.\n\nEdges are represented as links between nodes with optional\nkey/value attributes.\n\nSee Also\n--------\nDiGraph\nMultiGraph\nMultiDiGraph","extends":null,"methods":[{"name":"toString","computed":false,"isAsync":false,"params":[],"description":"Return the graph name","returns":{"name":"Graph","type":{"type":"NameExpression","name":"string"},"typeAsHTML":"string","descr":"name."}},{"name":"forEach","computed":false,"isAsync":false,"params":[{"name":"callback"},{"name":"optThisValue"}]},{"name":"get","computed":false,"isAsync":false,"params":[{"name":"n","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"A node in the graph."}],"description":"Return a dict of neighbors of node n.","returns":{"name":"The","type":{"type":"NameExpression","name":"Map","nullable":false},"typeAsHTML":"!Map","descr":"adjacency dictionary for nodes\n  connected to n."}},{"name":"addNode","computed":false,"isAsync":false,"params":[{"name":"n","type":{"type":"NameExpression","name":"Node","nullable":false},"typeAsHTML":"!Node","descr":"A node."},{"name":{"name":"optAttrDict"},"type":{"type":"NameExpression","name":"Object","optional":true},"typeAsHTML":"Object=","descr":"Dictionary of node attributes.\n     Key/value pairs will update existing data associated with the node.","defaultValue":"{}"}],"description":"Add a single node n and update node attributes.\n\nSince JavaScript does not provide keyword arguments,\nall attributes must be passed in an object as second\nargument."},{"name":"addNodesFrom","computed":false,"isAsync":false,"params":[{"name":"nodes","type":{"type":"NameExpression","name":"NodeContainer","nullable":false},"typeAsHTML":"!NodeContainer","descr":"A container of nodes (Array, Object, Array-like).\n      OR\n      A container of (node, attribute dict) tuples."},{"name":{"name":"optAttr"},"type":{"type":"NameExpression","name":"Object","optional":true},"typeAsHTML":"Object=","descr":"Update attributes for all nodes in nodes.\n      Node attributes specified in nodes as a tuple\n      take precedence over attributes specified generally.","defaultValue":"{}"}],"description":"Add multiple nodes.\n\nSince JavaScript does not provide keyword arguments,\nall attributes must be passed in an object as second\nargument."},{"name":"removeNode","computed":false,"isAsync":false,"params":[{"name":"n","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"A node in the graph."}],"description":"Remove node n.\n\nRemoves the node n and all adjacent edges.\nAttempting to remove a non-existent node will raise an exception."},{"name":"removeNodesFrom","computed":false,"isAsync":false,"params":[{"name":"nodes","type":{"type":"NameExpression","name":"NodeContainer"},"typeAsHTML":"NodeContainer","descr":"A container of nodes\n     If a node in the container is not in the graph it is silently ignored."}],"description":"Remove multiple nodes."},{"name":"nodesIter","computed":false,"isAsync":false,"params":[{"name":"optData","type":{"type":"NameExpression","name":"boolean","optional":true},"typeAsHTML":"boolean=","descr":"(default false) If false the iterator returns\n  nodes. If true return a two-tuple of node and node data dictionary."}],"description":"Return an iterator over the nodes.","returns":{"name":"of","type":{"type":"NameExpression","name":"Iterator"},"typeAsHTML":"Iterator","descr":"nodes If data=true the iterator gives\n          two-tuples containing (node, node data, dictionary)."}},{"name":"nodes","computed":false,"isAsync":false,"params":[{"name":"optData","type":{"type":"NameExpression","name":"boolean","optional":true},"typeAsHTML":"boolean=","descr":"(default false) If false the iterator returns\n  nodes. If true return a two-tuple of node and node data dictionary."}],"description":"Return a list of the nodes in the graph.","returns":{"name":"of","type":{"type":"NameExpression","name":"Array","nullable":false},"typeAsHTML":"!Array","descr":"nodes If data=true a list of two-tuples containing\n          (node, node data dictionary)."}},{"name":"numberOfNodes","computed":false,"isAsync":false,"params":[],"description":"Return the number of nodes in the graph.","returns":{"name":"The","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","descr":"number of nodes in the graph."}},{"name":"order","computed":false,"isAsync":false,"params":[],"description":"Return the number of nodes in the graph.","returns":{"name":"The","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","descr":"number of nodes in the graph."}},{"name":"hasNode","computed":false,"isAsync":false,"params":[{"name":"n","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Node"},{"type":"NameExpression","name":"NodeContainer"}],"nullable":false},"typeAsHTML":"!(Node|NodeContainer)","descr":"node."}],"description":"Return true if the graph contains the node n.","returns":{"type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean"}},{"name":"addEdge","computed":false,"isAsync":false,"params":[{"name":"u","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"Node."},{"name":"v","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"Node."},{"name":"optAttrDict","type":{"type":"NameExpression","name":"Object","optional":true,"nullable":true},"typeAsHTML":"?Object=","descr":"Dictionary of edge attributes.\n     Key/value pairs will update existing data associated with the edge."}],"description":"Add an edge between u and v.\n\nThe nodes u and v will be automatically added if they are\nnot already in the graph.\n\nEdge attributes can be specified by providing\na dictionary with key/value pairs.\n\nUnlike in Python, attributes can only be defined\nvia the dictionary."},{"name":"addEdgesFrom","computed":false,"isAsync":false,"params":[{"name":"ebunch","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","descr":"container of edges\n     Each edge given in the container will be added to the\n     graph. The edges must be given as as 2-tuples (u,v) or\n     3-tuples (u,v,d) where d is a dictionary containing edge\n     data."},{"name":"optAttrDict","type":{"type":"NameExpression","name":"Object","optional":true},"typeAsHTML":"Object=","descr":"Dictionary of edge attributes.  Key/value pairs will\n    update existing data associated with each edge."}],"description":"Add all the edges in ebunch.\n\nAdding the same edge twice has no effect but any edge data\nwill be updated when each duplicate edge is added.\n\nEdge attributes specified in edges as a tuple take precedence\nover attributes specified generally."},{"name":"addWeightedEdgesFrom","computed":false,"isAsync":false,"params":[{"name":"ebunch","type":{"type":"UnknownLiteral"},"typeAsHTML":"?","descr":"container of edges\n     Each edge given in the list or container will be added\n     to the graph. The edges must be given as 3-tuples (u,v,w)\n     where w is a number."},{"name":"optWeight","type":{"type":"NameExpression","name":"string","optional":true},"typeAsHTML":"string=","descr":"(default 'weight')\n     The attribute name for the edge weights to be added."},{"name":"optAttr","type":{"type":"NameExpression","name":"Object","optional":true},"typeAsHTML":"Object=","descr":"Edge attributes to add/update for all edges."}],"description":"Add all the edges in ebunch as weighted edges with specified weights.\n\n\nAdding the same edge twice for Graph/DiGraph simply updates\nthe edge data.  For MultiGraph/MultiDiGraph, duplicate edges\nare stored.\n\nSince JavaScript does not support keyword arguments, all attributes\nmust be passed in the attr object."},{"name":"removeEdge","computed":false,"isAsync":false,"params":[{"name":"u","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"Node."},{"name":"v","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"Node."}],"description":"Remove the edge between u and v."},{"name":"removeEdgesFrom","computed":false,"isAsync":false,"params":[{"name":"ebunch","type":{"type":"UnknownLiteral"},"typeAsHTML":"?","descr":"1list or container of edge tuples\n     Each edge given in the list or container will be removed\n     from the graph. The edges can be:\n         - 2-tuples (u,v) edge between u and v.\n         - 3-tuples (u,v,k) where k is ignored."}],"description":"Remove all edges specified in ebunch.\n\nNotes: Will fail silently if an edge in ebunch is not in the graph."},{"name":"hasEdge","computed":false,"isAsync":false,"params":[{"name":"u","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"Node."},{"name":"v","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"Node."}],"description":"Return True if the edge (u,v) is in the graph.","returns":{"name":"True","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","descr":"if edge is in the graph, False otherwise."}},{"name":"neighbors","computed":false,"isAsync":false,"params":[{"name":"n","type":{"type":"NameExpression","name":"Node","nullable":false},"typeAsHTML":"!Node","descr":"A node in the graph."}],"description":"Return a list of the nodes connected to the node n.","returns":{"name":"A","type":{"type":"NameExpression","name":"Array","nullable":false},"typeAsHTML":"!Array","descr":"list of nodes that are adjacent to n."}},{"name":"neighborsIter","computed":false,"isAsync":false,"params":[{"name":"n","type":{"type":"NameExpression","name":"Node","nullable":false},"typeAsHTML":"!Node","descr":"A node in the graph."}],"description":"Return an iterator over all neighbors of node n.","returns":{"name":"A","type":{"type":"NameExpression","name":"Iterator","nullable":false},"typeAsHTML":"!Iterator","descr":"list of nodes that are adjacent to n."}},{"name":"edges","computed":false,"isAsync":false,"params":[{"name":"optNbunch","type":{"type":"NameExpression","name":"NodeContainer","optional":true,"nullable":true},"typeAsHTML":"?NodeContainer=","descr":"A container of nodes.\n     The container will be iterated through once."},{"name":"optData","type":{"type":"NameExpression","name":"boolean","optional":true,"nullable":true},"typeAsHTML":"?boolean=","descr":"Return two tuples (u,v) (False)\n     or three-tuples (u,v,data) (True)."}],"description":"Return a list of edges.\n\nEdges are returned as tuples with optional data\nin the order (node, neighbor, data).\n\nNote: Nodes in nbunch that are not in the graph will be (quietly) ignored.\nFor directed graphs this returns the out-edges.","returns":{"name":"list","type":{"type":"NameExpression","name":"Array","nullable":false},"typeAsHTML":"!Array","descr":"of edge tuples\n     Edges that are adjacent to any node in nbunch, or a list\n     of all edges if nbunch is not specified."}},{"name":"edgesIter","computed":false,"isAsync":false,"params":[{"name":"optNbunch","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"NodeContainer"},{"type":"NameExpression","name":"boolean"}],"optional":true,"nullable":true},"typeAsHTML":"?(NodeContainer|boolean)=","descr":"A container of nodes.\n     The container will be iterated through once."},{"name":"optData","type":{"type":"NameExpression","name":"boolean","optional":true,"nullable":true},"typeAsHTML":"?boolean=","descr":"Return two tuples (u,v) (False)\n     or three-tuples (u,v,data) (True)."}],"description":"Return an iterator over the edges.\n\nEdges are returned as tuples with optional data\nin the order (node, neighbor, data).\n\nNote: Nodes in nbunch that are not in the graph will be (quietly) ignored.\nFor directed graphs this returns the out-edges.","returns":{"name":"list","type":{"type":"NameExpression","name":"Iterator","nullable":false},"typeAsHTML":"!Iterator","descr":"of edge tuples\n     Edges that are adjacent to any node in nbunch, or a list\n     of all edges if nbunch is not specified."}},{"name":"getEdgeData","computed":false,"isAsync":false,"params":[{"name":"u","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"Node."},{"name":"v","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"Node."},{"name":"optDefault","type":{"type":"NameExpression","name":"T","optional":true},"typeAsHTML":"T=","descr":"(default=null)\n     Value to return if the edge (u,v) is not found."}],"description":"Return the attribute dictionary associated with edge (u,v).","returns":{"name":"The","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Object"},{"type":"NameExpression","name":"T"}]},"typeAsHTML":"(Object|T)","descr":"edge attribute dictionary."}},{"name":"adjacencyList","computed":false,"isAsync":false,"params":[],"description":"Return an adjacency list representation of the graph.\n\nThe output adjacency list is in the order of G.nodes().\nFor directed graphs, only outgoing adjacencies are included.","returns":{"name":"The","type":{"type":"TypeApplication","expression":{"type":"NameExpression","name":"Array"},"applications":[{"type":"NameExpression","name":"Array"}],"nullable":false},"typeAsHTML":"!Array.&lt;Array>","descr":"adjacency structure of the graph as a\n     list of lists."}},{"name":"adjacencyIter","computed":false,"isAsync":false,"params":[],"description":"Return an iterator of (node, adjacency dict) tuples for all nodes.\n","returns":{"name":"An","type":{"type":"NameExpression","name":"Iterator","nullable":false},"typeAsHTML":"!Iterator","descr":"array of (node, adjacency dictionary)\n     for all nodes in the graph."}},{"name":"degree","computed":false,"isAsync":false,"params":[{"name":"optNbunch","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Node"},{"type":"NameExpression","name":"NodeContainer"}],"optional":true},"typeAsHTML":"(Node|NodeContainer)=","descr":"(default=all nodes)\n     A container of nodes.  The container will be iterated\n     through once."},{"name":"optWeight","type":{"type":"NameExpression","name":"string","optional":true},"typeAsHTML":"string=","descr":"(default=None)\n     The edge attribute that holds the numerical value used\n     as a weight.  If null or not defined, then each edge has weight 1.\n     The degree is the sum of the edge weights adjacent to the node."}],"description":"Return the degree of a node or nodes.\n\nThe node degree is the number of edges adjacent to that node.\n\nWARNING: Since both parameters are optional, and the weight attribute\nname could be equal to a node name, nbunch as to be set to null explicitly\nto use the second argument as weight attribute name.","returns":{"name":"A","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"number"},{"type":"NameExpression","name":"Map"}],"nullable":false},"typeAsHTML":"!(number|Map)","descr":"dictionary with nodes as keys and\ndegree as values or a number if a single node is specified."}},{"name":"degreeIter","computed":false,"isAsync":false,"params":[{"name":"optNbunch","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Node"},{"type":"NameExpression","name":"NodeContainer"}],"optional":true},"typeAsHTML":"(Node|NodeContainer)=","descr":"(default=all nodes)\n      A container of nodes.  The container will be iterated\n      through once."},{"name":"optWeight","type":{"type":"NameExpression","name":"string","optional":true},"typeAsHTML":"string=","descr":"(default=None)\n     The edge attribute that holds the numerical value used\n     as a weight.  If null or not defined, then each edge has weight 1.\n     The degree is the sum of the edge weights adjacent to the node."}],"description":["Return an array for (node, degree).\n","WARNING: Since both parameters are optional, and the weight attribute\nname could be equal to a node name, nbunch as to be set to null explicitly\nto use the second argument as weight attribute name."],"returns":{"name":"of","type":{"type":"NameExpression","name":"Iterator","nullable":false},"typeAsHTML":"!Iterator","descr":"two-tuples of (node, degree)."}},{"name":"clear","computed":false,"isAsync":false,"params":[],"description":"Remove all nodes and edges from the graph.\n\nThis also removes the name, and all graph, node, and edge attributes."},{"name":"copy","computed":false,"isAsync":false,"params":[],"description":"Return a copy of the graph.\n\nThis makes a complete copy of the graph including all of the\nnode or edge attributes.","returns":{"type":{"type":"NameExpression","name":"Graph","nullable":false},"typeAsHTML":"!Graph"}},{"name":"isMultigraph","computed":false,"isAsync":false,"params":[],"description":"Return True if graph is a multigraph, False otherwise.","returns":{"name":"True","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","descr":"if graph is a multigraph, False otherwise."}},{"name":"isDirected","computed":false,"isAsync":false,"params":[],"description":"Return True if graph is directed, False otherwise.","returns":{"name":"True","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","descr":"if graph is directed, False otherwise."}},{"name":"toDirected","computed":false,"isAsync":false,"params":[],"description":"Return a directed representation of the graph.\n\nThis returns a \"deepcopy\" of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references.\n\nThis is in contrast to the similar D=DiGraph(G) which returns a\nshallow copy of the data.","returns":{"type":{"type":"NameExpression","name":"DiGraph","nullable":false},"typeAsHTML":"!DiGraph"}},{"name":"toUndirected","computed":false,"isAsync":false,"params":[],"description":"Return an undirected copy of the graph.\n\nThis returns a \"deepcopy\" of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references.\n\nThis is in contrast to the similar G=DiGraph(D) which returns a\nshallow copy of the data.","returns":{"type":{"type":"NameExpression","name":"Graph","nullable":false},"typeAsHTML":"!Graph"}},{"name":"subgraph","computed":false,"isAsync":false,"params":[{"name":"nbunch","type":{"type":"NameExpression","name":"NodeContainer"},"typeAsHTML":"NodeContainer","descr":"A container of nodes which will be iterated through once."}],"description":"Return the subgraph induced on nodes in nbunch.\n\nThe induced subgraph of the graph contains the nodes in nbunch\nand the edges between those nodes.\n\nThe graph, edge or node attributes just point to the original graph.\nSo changes to the node or edge structure will not be reflected in\nthe original graph while changes to the attributes will.\n\nTo create a subgraph with its own copy of the edge/node attributes use:\n`jsnx.Graph(G.subgraph(nbunch))`.\n\nIf edge attributes are containers, a deep copy can be obtained using:\n`G.subgraph(nbunch).copy()`\n\nFor an inplace reduction of a graph to a subgraph you can remove nodes:\n\n```\nG.removeNodesFrom(G.nodes().filter(function(n) {\n     return nbunch.indexOf(n) > -1;\n}))\n```","returns":{"type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}},{"name":"nodesWithSelfloops","computed":false,"isAsync":false,"params":[],"description":"Return a list of nodes with self loops.\n\nA node with a self loop has an edge with both ends adjacent\nto that node.","returns":{"name":"A","type":{"type":"TypeApplication","expression":{"type":"NameExpression","name":"Array"},"applications":[{"type":"NameExpression","name":"string"}]},"typeAsHTML":"Array.&lt;string>","descr":"list of nodes with self loops."}},{"name":"selfloopEdges","computed":false,"isAsync":false,"params":[{"name":"optData","type":{"type":"NameExpression","name":"boolean","optional":true},"typeAsHTML":"boolean=","descr":"(default=False)\n     Return selfloop edges as two tuples (u,v) (data=False)\n     or three-tuples (u,v,data) (data=True)."}],"description":"Return a list of selfloop edges.\n\nA selfloop edge has the same node at both ends.","returns":{"name":"A","type":{"type":"NameExpression","name":"Array"},"typeAsHTML":"Array","descr":"list of all selfloop edges."}},{"name":"numberOfSelfloops","computed":false,"isAsync":false,"params":[],"description":"Return the number of selfloop edges.\n\nA selfloop edge has the same node at both ends.","returns":{"name":"The","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","descr":"number of selfloops."}},{"name":"size","computed":false,"isAsync":false,"params":[{"name":"optWeight","type":{"type":"NameExpression","name":"string","optional":true},"typeAsHTML":"string=","descr":"The edge attribute that holds the numerical\n     value used as a weight.  If not defined, then each edge has weight 1."}],"description":"Return the number of edges.","returns":{"name":"The","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","descr":"number of edges or sum of edge weights in the graph."}},{"name":"numberOfEdges","computed":false,"isAsync":false,"params":[{"name":"u","type":{"type":"NameExpression","name":"Node","optional":true,"nullable":false},"typeAsHTML":"!Node=","descr":"node."},{"name":"v","type":{"type":"NameExpression","name":"Node","optional":true,"nullable":false},"typeAsHTML":"!Node=","descr":"node\n      If u and v are specified, return the number of edges between\n      u and v. Otherwise return the total number of all edges."}],"description":"Return the number of edges between two nodes.","returns":{"name":"The","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","descr":"number of edges in the graph.\n     If nodes u and v are specified return the number of edges between\n     those nodes."}},{"name":"addStar","computed":false,"isAsync":false,"params":[{"name":"nodes","type":{"type":"NameExpression","name":"NodeContainer"},"typeAsHTML":"NodeContainer","descr":"A container of nodes."},{"name":"optAttr","type":{"type":"NameExpression","name":"Object","optional":true},"typeAsHTML":"Object=","descr":"Attributes to add to every edge in star."}],"description":"Add a star.\n\nThe first node in nodes is the middle of the star.  It is connected\nto all other nodes."},{"name":"addPath","computed":false,"isAsync":false,"params":[{"name":"nodes","type":{"type":"NameExpression","name":"NodeContainer"},"typeAsHTML":"NodeContainer","descr":"A container of nodes.\n     A path will be constructed from the nodes (in order)\n     and added to the graph."},{"name":"optAttr","type":{"type":"NameExpression","name":"Object","optional":true},"typeAsHTML":"Object=","descr":"Attributes to add to every edge in path."}],"description":"Add a path."},{"name":"addCycle","computed":false,"isAsync":false,"params":[{"name":"nodes","type":{"type":"NameExpression","name":"NodeContainer"},"typeAsHTML":"NodeContainer","descr":"A container of nodes.\n     A cycle will be constructed from the nodes (in order)\n     and added to the graph."},{"name":"optAttr","type":{"type":"NameExpression","name":"Object","optional":true},"typeAsHTML":"Object=","descr":"Attributes to add to every edge in cycle."}],"description":"Add a cycle."},{"name":"nbunchIter","computed":false,"isAsync":false,"params":[{"name":"optNbunch","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Node"},{"type":"NameExpression","name":"NodeContainer"}],"optional":true},"typeAsHTML":"(Node|NodeContainer)=","descr":"(default=all nodes)\n     A container of nodes.  The container will be iterated\n     through once."}],"description":"Return an iterator of nodes contained in nbunch that are\nalso in the graph.\n\nThe nodes in nbunch are checked for membership in the graph\nand if not are silently ignored.\n\nNotes\n-----\nWhen nbunch is an iterator, the returned iterator yields values\ndirectly from nbunch, becoming exhausted when nbunch is exhausted.\n\nTo test whether nbunch is a single node, one can use\n\"if(this.has_node(nbunch)\", even after processing with this routine.\n\nIf nbunch is not a node or a (possibly empty) sequence/iterator\nor not defined, an Error is raised.","returns":{"name":"An","type":{"type":"NameExpression","name":"Iterator","nullable":false},"typeAsHTML":"!Iterator","descr":"iterator over nodes in nbunch\n     that are also in the graph.\n     If nbunch is null or not defined, iterate over all nodes in the graph."}},{"name":"Symbol.iterator","computed":true,"isAsync":false,"params":[]}],"properties":[{"name":"name","computed":false,"isAsync":false,"params":[],"description":"Gets or sets the name of the graph.","returns":{"name":"Graph","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"string"},{"type":"UndefinedLiteral"}]},"typeAsHTML":"(string|undefined)","descr":"name if no parameter was passed."},"readonly":false}],"staticMethods":[],"staticProperties":[{"name":"__name__","computed":false,"isAsync":false,"params":[],"description":"Holds the graph type (class) name for information.\nThis is compatible to Pythons __name__ property.","readonly":true}],"constructor":{"name":"Graph","computed":false,"isAsync":false,"params":[{"name":"optData"},{"name":"optAttr"}]}},"DiGraph":{"name":"DiGraph","aliases":["DiGraph","classes.DiGraph"],"isClass":true,"description":"Base class for directed graphs.\n\nA DiGraph stores nodes and edges with optional data, or attributes.\n\nDiGraphs hold directed edges.  Self loops are allowed but multiple\n(parallel) edges are not.\n\nNodes can be arbitrary (hashable) Python objects with optional\nkey/value attributes.\n\nEdges are represented as links between nodes with optional\nkey/value attributes.","extends":"Graph","methods":[{"name":"addNode","computed":false,"isAsync":false,"params":[{"name":"n","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"Node"},{"name":{"name":"optAttrDict"},"type":{"type":"NameExpression","name":"Object","optional":true},"typeAsHTML":"Object=","descr":"Dictionary of node attributes.\n     Key/value pairs will update existing data associated with the node.","defaultValue":"{}"}],"description":"Add a single node n and update node attributes."},{"name":"addNodesFrom","computed":false,"isAsync":false,"params":[{"name":"nodes","type":{"type":"NameExpression","name":"NodeContainer"},"typeAsHTML":"NodeContainer","descr":"A container of nodes (list, dict, set, etc.).\n     OR\n     A container of (node, attribute dict) tuples."},{"name":{"name":"optAttr"},"type":{"type":"NameExpression","name":"Object","optional":true},"typeAsHTML":"Object=","descr":"Update attributes for all nodes in nodes.\n      Node attributes specified in nodes as a tuple\n      take precedence over attributes specified generally.","defaultValue":"{}"}],"description":"Add multiple nodes."},{"name":"removeNode","computed":false,"isAsync":false,"params":[{"name":"n","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"A node in the graph"}],"description":"Remove node n.\n\nRemoves the node n and all adjacent edges.\nAttempting to remove a non-existent node will raise an exception."},{"name":"removeNodesFrom","computed":false,"isAsync":false,"params":[{"name":"nodes","type":{"type":"NameExpression","name":"NodeContainer"},"typeAsHTML":"NodeContainer","descr":"A container of nodes.\n     If a node in the container is not in the graph it is silently ignored."}],"description":"Remove multiple nodes."},{"name":"addEdge","computed":false,"isAsync":false,"params":[{"name":"u","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"Node"},{"name":"v","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"Node"},{"name":{"name":"optAttrDict"},"type":{"type":"NameExpression","name":"Object","optional":true},"typeAsHTML":"Object=","descr":"Dictionary of edge attributes.\n     Key/value pairs will update existing data associated with the edge.","defaultValue":"{}"}],"description":["Add an edge between u and v.\n\nThe nodes u and v will be automatically added if they are\nnot already in the graph.\n\nEdge attributes can be specified with keywords or by providing\na dictionary with key/value pairs.","Note: Adding an edge that already exists updates the edge data.\n\n      Many NetworkX algorithms designed for weighted graphs use as\n      the edge weight a numerical value assigned to a keyword\n      which by default is 'weight'."]},{"name":"addEdgesFrom","computed":false,"isAsync":false,"params":[{"name":"ebunch","type":{"type":"UnknownLiteral"},"typeAsHTML":"?","descr":"container of edges\n     Each edge given in the container will be added to the\n     graph. The edges must be given as as 2-tuples (u,v) or\n     3-tuples (u,v,d) where d is a dictionary containing edge data."},{"name":{"name":"optAttrDict"},"type":{"type":"NameExpression","name":"Object","optional":true},"typeAsHTML":"Object=","descr":"Dictionary of edge attributes.\n     Dictionary of edge attributes.  Key/value pairs will\n     update existing data associated with each edge.","defaultValue":"{}"}],"description":"Add all the edges in ebunch.\n\nNotes:\nAdding the same edge twice has no effect but any edge data\nwill be updated when each duplicate edge is added."},{"name":"removeEdge","computed":false,"isAsync":false,"params":[{"name":"u","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"Node"},{"name":"v","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"Node"}],"description":"Remove the edge between u and v."},{"name":"removeEdgesFrom","computed":false,"isAsync":false,"params":[{"name":"ebunch","type":{"type":"UnknownLiteral"},"typeAsHTML":"?","descr":"1list or container of edge tuples\n     Each edge given in the list or container will be removed\n     from the graph. The edges can be:\n         - 2-tuples (u,v) edge between u and v.\n         - 3-tuples (u,v,k) where k is ignored."}],"description":"Remove all edges specified in ebunch.\n\nNotes: Will fail silently if an edge in ebunch is not in the graph."},{"name":"hasSuccessor","computed":false,"isAsync":false,"params":[{"name":"u","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"Node"},{"name":"v","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"Node"}],"description":"Return True if node u has successor v.\n\nThis is true if graph has the edge u->v.","returns":{"name":"True","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","descr":"if node u has successor v"}},{"name":"hasPredecessor","computed":false,"isAsync":false,"params":[{"name":"u","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"Node"},{"name":"v","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"Node"}],"description":"Return True if node u has predecessor v.\n\nThis is true if graph has the edge u<-v.","returns":{"name":"True","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","descr":"if node u has predecessor v"}},{"name":"successorsIter","computed":false,"isAsync":false,"params":[{"name":"n","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"Node"}],"description":"Return an iterator over successor nodes of n.\n\n{@code neighbors_iter()} and {@code successors_iter()} are the same.","returns":{"name":"Iterator","type":{"type":"NameExpression","name":"Iterator","nullable":false},"typeAsHTML":"!Iterator","descr":"over successor nodes of n"}},{"name":"predecessorsIter","computed":false,"isAsync":false,"params":[{"name":"n","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"Node"}],"description":"Return an iterator over predecessor nodes of n.","returns":{"name":"Iterator","type":{"type":"NameExpression","name":"Iterator","nullable":false},"typeAsHTML":"!Iterator","descr":"over predecessor nodes of n"}},{"name":"successors","computed":false,"isAsync":false,"params":[{"name":"n","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"Node"}],"description":"Return a list of successor nodes of n.\n\n{@code neighbors()} and {@code successors()} are the same.","returns":{"name":"List","type":{"type":"NameExpression","name":"Array","nullable":false},"typeAsHTML":"!Array","descr":"of successor nodes of n"}},{"name":"predecessors","computed":false,"isAsync":false,"params":[{"name":"n","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"Node"}],"description":"Return list of predecessor nodes of n.","returns":{"name":"List","type":{"type":"NameExpression","name":"Array","nullable":false},"typeAsHTML":"!Array","descr":"of predecessor nodes of n"}},{"name":"edgesIter","computed":false,"isAsync":false,"params":[{"name":"optNbunch","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"NodeContainer"},{"type":"NameExpression","name":"boolean"}],"optional":true,"nullable":true},"typeAsHTML":"?(NodeContainer|boolean)=","descr":"A container of nodes.\n      The container will be iterated through once."},{"name":{"name":"optData"},"type":{"type":"NameExpression","name":"boolean","optional":true,"nullable":true},"typeAsHTML":"?boolean=","descr":"If True, return edge attribute dict in 3-tuple (u,v,data).","defaultValue":"false"}],"description":["Return an iterator over the edges.\n\nEdges are returned as tuples with optional data\nin the order (node, neighbor, data).","Note:\n\n     Nodes in nbunch that are not in the graph will be (quietly) ignored."],"returns":{"name":"An","type":{"type":"NameExpression","name":"Iterator","nullable":false},"typeAsHTML":"!Iterator","descr":"iterator of (u,v) or (u,v,d) tuples of edges."}},{"name":"outEdgesIter","computed":false,"isAsync":false,"params":[{"name":"optNbunch"},{"name":"optData"}],"description":""},{"name":"outEdges","computed":false,"isAsync":false,"params":[{"name":"optNbunch"},{"name":"optData"}],"description":""},{"name":"inEdgesIter","computed":false,"isAsync":false,"params":[{"name":"optNbunch","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"NodeContainer","nullable":true},{"type":"NameExpression","name":"boolean"}],"optional":true},"typeAsHTML":"(?NodeContainer|boolean)=","descr":"A container of nodes.\n      The container will be iterated through once."},{"name":{"name":"optData"},"type":{"type":"NameExpression","name":"boolean","optional":true,"nullable":true},"typeAsHTML":"?boolean=","descr":"If True, return edge attribute dict in 3-tuple (u,v,data).","defaultValue":"false"}],"description":"Return an iterator over the incoming edges.","returns":{"name":"An","type":{"type":"NameExpression","name":"Iterator","nullable":false},"typeAsHTML":"!Iterator","descr":"iterator of (u,v) or (u,v,d) tuples of\n     incoming edges."}},{"name":"inEdges","computed":false,"isAsync":false,"params":[{"name":"optNbunch","type":{"type":"NameExpression","name":"NodeContainer"},"typeAsHTML":"NodeContainer","descr":"A container of nodes.\n      The container will be iterated through once."},{"name":{"name":"optData"},"type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","descr":"If True, return edge attribute dict in 3-tuple (u,v,data).","defaultValue":"false"}],"description":"Return a list of the incoming edges.","returns":{"name":"A","type":{"type":"NameExpression","name":"Array","nullable":false},"typeAsHTML":"!Array","descr":"list of incoming edges"}},{"name":"degreeIter","computed":false,"isAsync":false,"params":[{"name":"optNbunch","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Node"},{"type":"NameExpression","name":"NodeContainer"}],"optional":true},"typeAsHTML":"(Node|NodeContainer)=","descr":"A container of nodes.\n      The container will be iterated through once."},{"name":"optWeight","type":{"type":"NameExpression","name":"string","optional":true},"typeAsHTML":"string=","descr":"The edge attribute that holds the numerical value used\n      as a weight.  If None, then each edge has weight 1.\n      The degree is the sum of the edge weights adjacent to the node."}],"description":["Return an iterator for (node, degree).\n\nThe node degree is the number of edges adjacent to the node.","WARNING: Since both parameters are optional, and the weight attribute\nname could be equal to a node name, nbunch as to be set to null explicitly\nto use the second argument as weight attribute name."],"returns":{"name":"The","type":{"type":"NameExpression","name":"Iterator","nullable":false},"typeAsHTML":"!Iterator","descr":"iterator returns two-tuples of (node, degree)."}},{"name":"inDegreeIter","computed":false,"isAsync":false,"params":[{"name":"optNbunch","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Node"},{"type":"NameExpression","name":"NodeContainer"}],"optional":true},"typeAsHTML":"(Node|NodeContainer)=","descr":"A container of nodes.\n      The container will be iterated through once."},{"name":"optWeight","type":{"type":"NameExpression","name":"string","optional":true},"typeAsHTML":"string=","descr":"The edge attribute that holds the numerical value used\n      as a weight.  If None, then each edge has weight 1.\n      The degree is the sum of the edge weights adjacent to the node."}],"description":["Return an iterator for (node, in-degree).\n\nThe node in-degree is the number of edges pointing in to the node.","WARNING: Since both parameters are optional, and the weight attribute\nname could be equal to a node name, nbunch as to be set to null explicitly\nto use the second argument as weight attribute name."],"returns":{"name":"The","type":{"type":"NameExpression","name":"Iterator"},"typeAsHTML":"Iterator","descr":"iterator returns two-tuples of (node, in-degree)."}},{"name":"outDegreeIter","computed":false,"isAsync":false,"params":[{"name":"optNbunch","type":{"type":"NameExpression","name":"NodeContainer","optional":true},"typeAsHTML":"NodeContainer=","descr":"A container of nodes.\n      The container will be iterated through once."},{"name":"optWeight","type":{"type":"NameExpression","name":"string","optional":true},"typeAsHTML":"string=","descr":"The edge attribute that holds the numerical value used\n      as a weight.  If None, then each edge has weight 1.\n      The degree is the sum of the edge weights adjacent to the node."}],"description":["Return an iterator for (node, out-degree).\n\nThe node out-degree is the number of edges pointing in to the node.","WARNING: Since both parameters are optional, and the weight attribute\nname could be equal to a node name, nbunch as to be set to null explicitly\nto use the second argument as weight attribute name."],"returns":{"name":"The","type":{"type":"NameExpression","name":"Iterator"},"typeAsHTML":"Iterator","descr":"iterator returns two-tuples of (node, out-degree)."}},{"name":"inDegree","computed":false,"isAsync":false,"params":[{"name":"optNbunch","type":{"type":"NameExpression","name":"NodeContainer","optional":true},"typeAsHTML":"NodeContainer=","descr":"A container of nodes.\n      The container will be iterated through once."},{"name":"optWeight","type":{"type":"NameExpression","name":"string","optional":true},"typeAsHTML":"string=","descr":"The edge attribute that holds the numerical value used\n      as a weight.  If None, then each edge has weight 1.\n      The degree is the sum of the edge weights adjacent to the node."}],"description":["Return the in-degree of a node or nodes.\n\nThe node in-degree is the number of edges pointing in to the node.","WARNING: Since both parameters are optional, and the weight attribute\nname could be equal to a node name, nbunch as to be set to null explicitly\nto use the second argument as weight attribute name."],"returns":{"name":"A","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"number"},{"type":"NameExpression","name":"Map"}]},"typeAsHTML":"(number|Map)","descr":"dictionary with nodes as keys and in-degree as values or\n      a number if a single node is specified."}},{"name":"outDegree","computed":false,"isAsync":false,"params":[{"name":"optNbunch","type":{"type":"NameExpression","name":"NodeContainer","optional":true},"typeAsHTML":"NodeContainer=","descr":"A container of nodes.\n      The container will be iterated through once."},{"name":"optWeight","type":{"type":"NameExpression","name":"string","optional":true},"typeAsHTML":"string=","descr":"The edge attribute that holds the numerical value used\n      as a weight.  If None, then each edge has weight 1.\n      The degree is the sum of the edge weights adjacent to the node."}],"description":["Return the out-degree of a node or nodes.\n\nThe node out-degree is the number of edges pointing out of the node.","WARNING: Since both parameters are optional, and the weight attribute\nname could be equal to a node name, nbunch as to be set to null explicitly\nto use the second argument as weight attribute name."],"returns":{"name":"A","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"number"},{"type":"NameExpression","name":"Map"}]},"typeAsHTML":"(number|Map)","descr":"dictionary with nodes as keys and in-degree as values or\n      a number if a single node is specified."}},{"name":"clear","computed":false,"isAsync":false,"params":[],"description":"Remove all nodes and edges from the graph.\n\nThis also removes the name, and all graph, node, and edge attributes."},{"name":"isMultigraph","computed":false,"isAsync":false,"params":[],"description":"Return True if graph is a multigraph, False otherwise.","returns":{"name":"True","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","descr":"if graph is a multigraph, False otherwise."}},{"name":"isDirected","computed":false,"isAsync":false,"params":[],"description":"Return True if graph is directed, False otherwise.","returns":{"name":"True","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","descr":"if graph is directed, False otherwise."}},{"name":"toDirected","computed":false,"isAsync":false,"params":[],"description":"Return a directed copy of the graph.\n\nNotes:\n\n     This returns a \"deepcopy\" of the edge, node, and\n     graph attributes which attempts to completely copy\n     all of the data and references.\n\n     This is in contrast to the similar D = new DiGraph(G) which returns a\n     shallow copy of the data.","returns":{"name":"A","type":{"type":"NameExpression","name":"DiGraph","nullable":false},"typeAsHTML":"!DiGraph","descr":"deepcopy of the graph"}},{"name":"toUndirected","computed":false,"isAsync":false,"params":[{"name":"optReciprocal","type":{"type":"NameExpression","name":"boolean","optional":true},"typeAsHTML":"boolean=","descr":"If True only keep edges that appear in both directions\n     in the original digraph."}],"description":"Return an undirected representation of the digraph.\n\nNotes:\n\nIf edges in both directions (u,v) and (v,u) exist in the\ngraph, attributes for the new undirected edge will be a combination of\nthe attributes of the directed edges.  The edge data is updated\nin the (arbitrary) order that the edges are encountered.  For\nmore customized control of the edge attributes use add_edge().\n\nThis returns a \"deepcopy\" of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references.\n\nThis is in contrast to the similar G=DiGraph(D) which returns a\nshallow copy of the data.","returns":{"name":"An","type":{"type":"NameExpression","name":"Graph","nullable":false},"typeAsHTML":"!Graph","descr":"undirected graph with the same name and nodes and\n     with edge (u,v,data) if either (u,v,data) or (v,u,data)\n     is in the digraph.  If both edges exist in digraph and\n     their edge data is different, only one edge is created\n     with an arbitrary choice of which edge data to use.\n     You must check and correct for this manually if desired."}},{"name":"reverse","computed":false,"isAsync":false,"params":[{"name":{"name":"optCopy"},"type":{"type":"NameExpression","name":"boolean","optional":true},"typeAsHTML":"boolean=","descr":"(default=True)\n     If True, return a new DiGraph holding the reversed edges.\n     If False, reverse the reverse graph is created using\n     the original graph (this changes the original graph).","defaultValue":"true"}],"description":"Return the reverse of the graph.\n\nThe reverse is a graph with the same nodes and edges\nbut with the directions of the edges reversed.","returns":{"name":"A","type":{"type":"NameExpression","name":"DiGraph","nullable":false},"typeAsHTML":"!DiGraph","descr":"copy of the graph or the graph itself"}},{"name":"subgraph","computed":false,"isAsync":false,"params":[{"name":"nbunch","type":{"type":"NameExpression","name":"NodeContainer"},"typeAsHTML":"NodeContainer","descr":"A container of nodes which will be iterated through once."}],"description":"Return the subgraph induced on nodes in nbunch.\n\nThe induced subgraph of the graph contains the nodes in nbunch\nand the edges between those nodes.\n\nNotes:\n\nThe graph, edge or node attributes just point to the original graph.\nSo changes to the node or edge structure will not be reflected in\nthe original graph while changes to the attributes will.\n\nTo create a subgraph with its own copy of the edge/node attributes use:\nnx.Graph(G.subgraph(nbunch))\n\nIf edge attributes are containers, a deep copy can be obtained using:\nG.subgraph(nbunch).copy()\n\nFor an inplace reduction of a graph to a subgraph you can remove nodes:\nG.remove_nodes_from([ n in G if n not in set(nbunch)])","returns":{"name":"A","type":{"type":"NameExpression","name":"DiGraph"},"typeAsHTML":"DiGraph","descr":"subgraph of the graph with the same edge\n  attributes.\n"}}],"properties":[{"name":"neighbors","computed":false,"isAsync":false,"params":[],"description":"","readonly":true},{"name":"neighborsIter","computed":false,"isAsync":false,"params":[],"description":"","readonly":true}],"staticMethods":[],"staticProperties":[{"name":"__name__","computed":false,"isAsync":false,"params":[],"description":"Holds the graph type (class) name for information.\nThis is compatible to Pythons __name__ property.","readonly":true}],"constructor":{"name":"DiGraph","computed":false,"isAsync":false,"params":[{"name":"optData"},{"name":"optAttr"}]}},"MultiGraph":{"name":"MultiGraph","aliases":["MultiGraph","classes.MultiGraph"],"isClass":true,"description":"An undirected graph class that can store multiedges.\n\nMultiedges are multiple edges between two nodes.  Each edge\ncan hold optional data or attributes. A MultiGraph holds undirected edges.\nSelf loops are allowed.\n\nEdges are represented as links between nodes with optional\nkey/value attributes.\n\n### Examples\n\nCreate an empty graph structure (a \"null graph\") with no nodes and no edges.\n\n```\nvar G = jsnx.MultiGraph();\n```\n\nG can be grown in several ways.\n\n#### Nodes\n\nAdd one node at a time:\n\n```\nG.addNode(1);\n```\n\nAdd the nodes from any iterable:\n\n```\nG.addNodesFrom([2, 3]);\nvar H = jsnx.Graph();\nH.addPath([0,1,2,3,4,5,6,7,8,9]);\nG.addNodesFrom(h);\n```\n\nIn addition to strings and integers, any object that implements a custom\n`toString` method can be used as node. For example, arrays:\n\n```\nG.addNode([1,2]);\n```\n\n#### Edges\n\nA graph can also be grown by adding edges.\n\nAdd one edge,\n\n```\nG.addEdge(1, 2);\n```\n\na list or collection of edges,\n\n```\nG.addEdgesFrom([[1,2], [1,3]]);\nG.addEdgesFrom(H.edges());\n```\n\nIf some edges connect nodes not yet in the graph, the nodes are added\nautomatically. If an edge already exists, an addition edge is created and\nstored using a key to identify the edge. By default, the key is the lowest\nunused integer.\n\n```\nG.addEdgesFrom([[4,5,{route: 282}], [4,5,{route: 37}]]);\nG.get(4);\n// Map { 3: {0: {}}, 5: {0: {}, 1: {route: 282}, 2: {route: 37}}}\n```\n\n#### Attributes\n\nEach graph, node and edge can hold key/value attribute pairs in an associated\nattribute \"dictionary\" (object). By defauly these are empty, but can be added\nor changed using `addEdge` or `addNode`.\n\n```\nvar G = jsnx.MultiGraph(null, {day: Friday}):\nG.graph\n// {day: 'Friday'}\n\nG.addNode(1, {time: '5pm'});\nG.addNodesFrom([3], {time: '2pm'});\nG.nodes(true);\n// [[1, {time: '5pm'}], [3, {time: '2pm'}]]\n```","extends":"Graph","methods":[{"name":"addEdge","computed":false,"isAsync":false,"params":[{"name":"u","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"node"},{"name":"v","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"node"},{"name":"optKey","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"number"},{"type":"NameExpression","name":"string"}],"optional":true,"nullable":true},"typeAsHTML":"?(number|string)=","descr":"identifier\n     Used to distinguish multiedges between a pair of nodes. Default is\n     the lowest unused integer."},{"name":"optAttrDict","type":{"type":"NameExpression","name":"Object","optional":true,"nullable":true},"typeAsHTML":"?Object=","descr":"Dictionary of edge attributes.\n     Key/value pairs will update existing data associated with the edge."}],"description":"Add an edge between u and v.\n\nThe nodes u and v will be automatically added if they are\nnot already in the graph.\n\nEdge attributes can be specified with keywords or by providing\na dictionary with key/value pairs.\n\n### Notes:\n\nTo replace/update edge data, use the optional key argument\nto identify a unique edge.  Otherwise a new edge will be created.\n\nNetworkX algorithms designed for weighted graphs cannot use\nmultigraphs directly because it is not clear how to handle\nmultiedge weights.  Convert to Graph using edge attribute\n'weight' to enable weighted graph algorithms.\n\n### Example\n\nThe following all add the edge [1,2] to the graph G:\n\n```\nvar G = jsnx.MultiGraph();\nvar e = [1,2];\nG.addEdge(1, 2);\nG.addEdge.apply(G, e);\nG.addEdgesFrom([e]);\n```\nAssociate data to edges by passing a data object:\n\n```\nG.addEdge(1, 2, {weight: 3});\nG.addEdge(1, 2, 0, {weight: 4}); // update data for key=0\nG.addEdge(1, 3, {weight: 7, capacity: 15, length: 342.7});\n```"},{"name":"addEdgesFrom","computed":false,"isAsync":false,"params":[{"name":"ebunch","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","descr":"container of edges\n     Each edge given in the container will be added to the\n     graph. The edges can be:"},{"name":"optAttrDict","type":{"type":"NameExpression","name":"Object","optional":true},"typeAsHTML":"Object=","descr":"Dictionary of edge attributes.\n      Key/value pairs will update existing data associated with each edge."}],"description":["Add all the edges in `ebunch`.\n\nAdding the same edge twice has no effect but any edge data will be updated\nwhen each duplicate edge is added.\n\nEdge attributes specified in edges as a tuple take precedence over the\nattributes specified generally.\n\n### Example\n\n```\nvar G = new jsnx.MultiGraph();\nG.addEdgesFrom([[0,1], [1,2]]);\n```\n\nAssociate data to edges\n\n```\nG.addEdgesFrom([[1,2], [2,3]], {weight: 3});\nG.addEdgesFrom([[1,2], [2,3]], {label: 'WN2898'});\n```","         - 2-tuples (u,v) or\n         - 3-tuples (u,v,d) for an edge attribute dict d or\n         - 4-tuples (u,v,k,d) for an edge identified by key k"]},{"name":"removeEdge","computed":false,"isAsync":false,"params":[{"name":"u","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node"},{"name":"v","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node"},{"name":"optKey","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"number"},{"type":"NameExpression","name":"string"}],"optional":true},"typeAsHTML":"(number|string)=","descr":"Used to distinguish multiple edges between a pair of nodes.\n     If null or undefined remove a single (arbitrary) edge between u and v."}],"description":"Remove an edge between u and v.\n\n### Example\n\n```\nvar G = new jsnx.MultiGraph();\nG.addPath([0,1,2,3]);\nG.removeEdge(0, 1);\n```\n\nFor multiple edges\n\n```\nvar G = new jsnx.MultiGraph();\nG.addEdgesFrom([[1,2], [1,2], [1,2]]);\nG.removeEdge(1, 2); // remove a single edge\n```\n\nFor edges with keys\n\n```\nvar G = new jsnx.MultiGraph();\nG.addEdge(1, 2, 'first');\nG.addEdge(1, 2, 'second');\nG.removeEdge(1, 2, 'second');\n```"},{"name":"removeEdgesFrom","computed":false,"isAsync":false,"params":[{"name":"ebunch","type":{"type":"UnknownLiteral"},"typeAsHTML":"?","descr":"list or container of edge tuples\n     Each edge given in the list or container will be removed\n     from the graph. The edges can be:"}],"description":["Remove all edges specified in `ebunch`.\n\nWill fail silently if an edge in `ebunch` is not in the graph.\n\n### Example\n\n```\nvar G = new jsnx.MultiGraph();\nG.addPath([0,1,2,3]);\nvar ebunch = [[1,2], [2,3]];\nG.removeEdgesFrom(ebunch);\n```\n\nRemoving multiple copies of edges.\n\n```\nvar G = new jsnx.MultiGraph();\nG.addEdgesFrom([[1,2], [1,2], [1,2]]);\nG.removeEdgesFrom([[1,2], [1,2]]);\nG.edges();\n// [[1,2]]\n```","       - 2-tuples (u,v) All edges between u and v are removed.\n       - 3-tuples (u,v,key) The edge identified by key is removed."]},{"name":"hasEdge","computed":false,"isAsync":false,"params":[{"name":"u","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"node"},{"name":"v","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"node"},{"name":"optKey","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"string"},{"type":"NameExpression","name":"number"}],"optional":true},"typeAsHTML":"(string|number)=","descr":"If specified return true only\n     if the edge with key is found."}],"description":"Return True if the graph has an edge between nodes u and v.\n\n### Example\n\n```\nvar G = new jsnx.MultiGraph();\nG.addPath([0,1,2,3]);\nG.hasEdge(0,1);\n// true\nG.addEdge(0, 1, 'a');\nG.hasEdge(0, 1, 'a');\n// true\n```\n\nThe following syntax are equivalent:\n\n```\nG.hasEdge(0, 1);\n// true\nG.get(0).has(1);\n// true\n```","returns":{"name":"true","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","descr":"if edge is in the graph, false otherwise."}},{"name":"edges","computed":false,"isAsync":false,"params":[{"name":"optNbunch","type":{"type":"NameExpression","name":"NodeContainer","optional":true,"nullable":true},"typeAsHTML":"?NodeContainer=","descr":"A container of nodes.\n     The container will be iterated through once."},{"name":"optData","type":{"type":"NameExpression","name":"boolean","optional":true,"nullable":true},"typeAsHTML":"?boolean=","descr":"(default=False)\n     Return two tuples (u,v) (False) or three-tuples (u,v,data) (True)."},{"name":"optKeys","type":{"type":"NameExpression","name":"boolean","optional":true,"nullable":true},"typeAsHTML":"?boolean=","descr":"(default=False)\n     Return two tuples (u,v) (False) or three-tuples (u,v,key) (True)."}],"description":"Return a list of edges.\n\nEdges are returned as tuples with optional data and keys in the order\n(node, neighbor, key, data).\n\nNodes in `nbunch` that are not in the graph will be (quietly) ignored.\n\n### Example\n\n```\nvar G = new jsnx.MultiGraph();\nG.addPath([0,1,2,3]);\nG.edges();\n// [[0,1], [1,2], [2,3]]\nG.edges(true);\n// [[0,1,{}], [1,2,{}], [2,3,{}]]\nG.edges(false, true);\n// [[0,1,0], [1,2,0], [2,3,0]]\nG.edges(true, true);\n// [[0,1,0,{}], [1,2,0,{}], [2,3,0,{}]]\nG.edges([0,3]);\n// [[0,1], [3, 2]]\nG.edges(0);\n// [[0,1]]\n```","returns":{"name":"list","type":{"type":"NameExpression","name":"Array","nullable":false},"typeAsHTML":"!Array","descr":"of edge tuples\n     Edges that are adjacent to any node in nbunch, or a list\n     of all edges if nbunch is not specified."}},{"name":"edgesIter","computed":false,"isAsync":false,"params":[{"name":"optNbunch","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"NodeContainer"},{"type":"NameExpression","name":"boolean"}],"optional":true,"nullable":true},"typeAsHTML":"?(NodeContainer|boolean)=","descr":"A container of nodes.\n     The container will be iterated through once."},{"name":{"name":"optData"},"type":{"type":"NameExpression","name":"boolean","optional":true,"nullable":true},"typeAsHTML":"?boolean=","descr":"(default=False)\n     If True, return edge attribute dict with each edge.","defaultValue":"false"},{"name":{"name":"optKeys"},"type":{"type":"NameExpression","name":"boolean","optional":true,"nullable":true},"typeAsHTML":"?boolean=","descr":"(default=False)\n     If True, return edge keys with each edge.","defaultValue":"false"}],"description":"Return an iterator over edges.\n\nEdges are returned as tuples with optional data and keys\nin the order (node, neighbor, key, data).\n\nNodes in nbunch that are not in the graph will be (quietly) ignored.\n\n### Example\n\n```\nvar G = new jsnx.MultiGraph();\nG.addPath([0,1,2,3]);\nArray.from(G.edgesIter);\n// [[0,1], [1,2], [2,3]]\nArray.from(G.edges(true));\n// [[0,1,{}], [1,2,{}], [2,3,{}]]\nArray.from(G.edges(false, true));\n// [[0,1,0], [1,2,0], [2,3,0]]\nArray.from(G.edges(true, true));\n// [[0,1,0,{}], [1,2,0,{}], [2,3,0,{}]]\nArray.from(G.edges([0,3]));\n// [[0,1], [3, 2]]\nArray.from(G.edges(0));\n// [[0,1]]\n```","returns":{"name":"An","type":{"type":"NameExpression","name":"Iterator","nullable":false},"typeAsHTML":"!Iterator","descr":"iterator of (u,v), (u,v,d) or (u,v,key,d) tuples of edges."}},{"name":"getEdgeData","computed":false,"isAsync":false,"params":[{"name":"u","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"node"},{"name":"v","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"node"},{"name":"optKey","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"string"},{"type":"NameExpression","name":"number"}],"optional":true},"typeAsHTML":"(string|number)=","descr":"Return data only for the edge with\n     specified key."},{"name":"optDefault","type":{"type":"NameExpression","name":"T","optional":true},"typeAsHTML":"T=","descr":"Value to return if the edge (u,v) is not found."}],"description":"Return the attribute dictionary associated with edge (u,v).\n\n### Example\n\n```\nvar G = jsnx.MultiGraph();\nG.addPath([0,1,2,3]);\nG.getEdgeData(0, 1);\n// {0: {}}\nG.getEdgeData('a', 'b', null, 0); // edge not in graph, return 0\n// 0\n```","returns":{"name":"The","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Object"},{"type":"NameExpression","name":"T"}]},"typeAsHTML":"(Object|T)","descr":"edge attribute dictionary."}},{"name":"degreeIter","computed":false,"isAsync":false,"params":[{"name":"optNbunch","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Node"},{"type":"NameExpression","name":"NodeContainer"}],"optional":true,"nullable":true},"typeAsHTML":"?(Node|NodeContainer)=","descr":"A container of nodes\n     The container will be iterated through once."},{"name":"optWeight","type":{"type":"NameExpression","name":"string","optional":true,"nullable":true},"typeAsHTML":"?string=","descr":"The edge attribute that holds the numerical\n     value used as a weight.  If undefined, then each edge has weight 1.\n     The degree is the sum of the edge weights adjacent to the node."}],"description":"Return an iterator for (node, degree).\n\nThe node degree is the number of edges adjacent to the node.\n\n### Example\n\n```\nvar G = new jsnx.Graph();\nG.addPath([0,1,2,3]);\nArray.from(G.degreeIter(0));\n// [[0,1]]  // node 0 with degree 1\nArray.from(G.degreeIter([0,1]));\n// [[0,1], [1,2]]","returns":{"name":"The","type":{"type":"NameExpression","name":"Iterator","nullable":false},"typeAsHTML":"!Iterator","descr":"iterator returns two-tuples of (node, degree)."}},{"name":"isMultigraph","computed":false,"isAsync":false,"params":[],"description":"Return true if graph is a multigraph, false otherwise.","returns":{"name":"true","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","descr":"if graph is a multigraph, false otherwise."}},{"name":"isDirected","computed":false,"isAsync":false,"params":[],"description":"Return true if graph is directed, false otherwise.","returns":{"name":"True","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","descr":"if graph is directed, False otherwise."}},{"name":"toDirected","computed":false,"isAsync":false,"params":[],"description":"Return a directed representation of the graph.\n\n### Notes\n\nThis returns a \"deepcopy\" of the edge, node, and graph attributes which\nattempts to completely copy all of the data and references.\n\nThis is in contrast to the similar D = DiGraph(G) which returns a shallow\ncopy of the data.\n\n### Example\n\n```\nvar G = new jsnx.MultiGraph();\nG.addPath([0,1]);\nvar H = G.toDirected();\nG.edges();\n// [[0,1], [1,0]]\n```\n\nIf already directed, return a (deep) copy\n\n```\nvar G = new jsnx.MultiDiGraph();\nG.addPath([0,1]);\nvar H = G.toDirected();\nG.edges();\n// [[0,1]]\n```","returns":{"name":"A","type":{"type":"NameExpression","name":"MultiDiGraph","nullable":false},"typeAsHTML":"!MultiDiGraph","descr":"directed graph with the same name, same nodes, and with\n     each edge (u,v,data) replaced by two directed edges\n     (u,v,data) and (v,u,data)."}},{"name":"selfloopEdges","computed":false,"isAsync":false,"params":[{"name":{"name":"optData"},"type":{"type":"NameExpression","name":"boolean","optional":true},"typeAsHTML":"boolean=","descr":"(default=False)\n     Return selfloop edges as two tuples (u,v) (data=False)\n     or three-tuples (u,v,data) (data=True)","defaultValue":"false"},{"name":{"name":"optKeys"},"type":{"type":"NameExpression","name":"boolean","optional":true},"typeAsHTML":"boolean=","descr":"(default=False)\n      If True, return edge keys with each edge","defaultValue":"false"}],"description":"Return a list of selfloop edges.\n\n### Example\n\n```\nvar G = new jsnx.MultiGraph();\nG.addEdge(1, 1);\nG.addEdge(1, 2);\nG.selfloopEdges();\n// [[1,1]]\nG.selfloopEdges(true);\n// [[1,1,{}]]\nG.selfloopEdges(false, true);\n// [[1,1,0]]\nG.selfloopEdges(true, true);\n// [[1,1,0,{}]]","returns":{"name":"A","type":{"type":"NameExpression","name":"Array"},"typeAsHTML":"Array","descr":"list of all selfloop edges"}},{"name":"numberOfEdges","computed":false,"isAsync":false,"params":[{"name":"optU","type":{"type":"NameExpression","name":"Node","optional":true},"typeAsHTML":"Node=","descr":"node"},{"name":"optV","type":{"type":"NameExpression","name":"Node","optional":true},"typeAsHTML":"Node=","descr":"node\n     If u and v are specified, return the number of edges between\n     u and v. Otherwise return the total number of all edges."}],"description":"Return the number of edges between two nodes.\n\n### Example\n\n```\nvar G = new jsnx.MultiGraph();\nG.addPath([0,1,2,3]);\nG.numberOfEdges();\n// 3\nG.numberOfEdges(0,1);\n// 1\n```","returns":{"name":"The","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","descr":"number of edges in the graph.\n     If nodes u and v are specified return the number of edges between\n     those nodes."}},{"name":"subgraph","computed":false,"isAsync":false,"params":[{"name":"nbunch","type":{"type":"NameExpression","name":"NodeContainer","optional":true},"typeAsHTML":"NodeContainer=","descr":"A container of nodes which will be\n     iterated through once."}],"description":"Return the subgraph induced on nodes in nbunch.\n\nThe induced subgraph of the graph contains the nodes in nbunch and the\nedges between those nodes.\n\n### Notes\n\nThe graph, edge or node attributes just point to the original graph.\nSo changes to the node or edge structure will not be reflected in\nthe original graph while changes to the attributes will.\n\nTo create a subgraph with its own copy of the edge/node attributes use:\n`jsnx.Graph(G.subgraph(nbunch))`\n\nIf edge attributes are containers, a deep copy can be obtained using:\n`G.subgraph(nbunch).copy()`.\n\n### Example\n\n```\nvar G = new jsnx.Graph();\nG.addPath([0,1,2,3]);\nvar H = G.subgraph([0,1,2]);\nH.edges();\n// [[0,1], [1,2]]\n```","returns":{"name":"A","type":{"type":"NameExpression","name":"MultiGraph"},"typeAsHTML":"MultiGraph","descr":"subgraph of the graph with the same edge attributes."}}],"properties":[],"staticMethods":[],"staticProperties":[{"name":"__name__","computed":false,"isAsync":false,"params":[],"description":"Holds the graph type (class) name for information.\nThis is compatible to Pythons __name__ property.","readonly":true}],"constructor":{"name":"MultiGraph","computed":false,"isAsync":false,"params":[{"name":"optData","type":{"type":"UnknownLiteral"},"typeAsHTML":"?","descr":"Data to initialze graph.\n     If no data is provided, an empty graph is created. The data can be\n     an edge list or any graph object."},{"name":"optAttr","type":{"type":"NameExpression","name":"Object","optional":true},"typeAsHTML":"Object=","descr":"Attributes to add to graph as key=value pairs."}],"description":""}},"MultiDiGraph":{"name":"MultiDiGraph","aliases":["MultiDiGraph","classes.MultiDiGraph"],"isClass":true,"description":"A directed graph class that can store multiedges.\n\nMultiedges are multiple edges between two nodes. Each edge can hold optional\ndata or attributes.\n\nA MultiDiGraph holds directed edges. Self loops are allowed. Edges are\nrespresented as links between nodes with optional key/value attributes.\n\n### Example\n\nCreate an empty graph structure (a \"null graph\") with no nodes and no edges:\n\n```\nvar G = new jsnx.MultiDiGraph();\n```\n\nG can be grown in several ways.\n\n#### Nodes\n\nAdd one node at a time:\n\n```\nG.addNode(1);\n```\n\nAdd the nodes from any iterable:\n\n```\nG.addNodesFrom([2,3]);\nvar H = new jsnx.Graph();\nH.addPath([0,1,2,3,4,5]);\nG.addNodesFrom(H);\n```\n\nIn addition to strings and integers, any object that implements a custom\n`toString` method can represent a node.\n\n#### Edges\n\n`G` can also be grown by adding edges. Add one edge,\n\n```\nG.addEdge(1, 2);\n```\n\na list of edges,\n\n```\nG.addEdgesFrom([[1,2], [1,3]]);\n```\n\nor a collection of edges\n\n```\nG.addEdgesFrom(H.edges());\n```\n\nIf some edges connect nodes not yet in the graph, the nodes are added\nautomatically. If an edge already exists, an additional edge is created and\nstored using a key to identify the edge. By default the key is the lowest\nunused integer.\n\n```\nG.addEdgesFrom([[4,5,{route:282}], [4,5,{route:37}]]);\nG.get(4);\n// Map {5: {0: {}, 1: {route: 282}, 2: {route: 37}}}\n\n#### Attributes\n\nEach graph, node and edge can hold key/value attribute pairs in an associated\nattribute object. By default these are empty, but can be added or changed\nusing `addEdge` or `addNode`.\n\n```\nG.addNode(1, {time: '5pm'});\nG.addNodesFrom([3], {time: '2pm'});\nG.nodes(true);\n// [[1, {time: '5pm'}], [3, {time: '2pm'}]]\n```\n\nAdd edge attributes using `addEdge` and `addEdgesFrom`:\n\n```\nG.addEdge(1, 2, {weight: 4.7});\nG.addEdgesFrom([[3,4], [4,5]], {color: 'red'});\nG.addEdgesFrom([[1,2,{color: 'blue'}], [2,3,{weight: 8}]]);\n```","extends":"DiGraph","methods":[{"name":"addEdge","computed":false,"isAsync":false,"params":[{"name":"u","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node"},{"name":"v","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node"},{"name":"optKey","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"string"},{"type":"NameExpression","name":"number"}]},"typeAsHTML":"(string|number)","descr":"(default=lowest unused integer) Used to\n  distinguish multiedges between a pair of nodes."},{"name":"optAttrDict","type":{"type":"NameExpression","name":"Object"},"typeAsHTML":"Object","descr":"Object of edge attributes. Key/value pairs will\n  update existing data associated with the edge."}],"description":"Add an edge between u and v.\n\nThe nodes u and v will be automatically added if they are not already in\nthe graph.\n\nEdge attributes can be specified by providing an object with key/value\npairs.\n\n### Note\n\nTo replace/update edge data, use the optional key argument to identify a\nunique edge. Otherwise a new edge will be created.\n\n### Example\n\nThe following add the edge e=(1,2) to graph G:\n\n```\nvar G = new jsnx.MultiDiGraph();\nG.addEdge(1, 2);\nG.addEdgesFrom([[1,2]]);\n```\n\nAssociate data to edges using keywords:\n\n```\nG.addEdge(1, 2, {weight: 3});\nG.addEdge(1, 2, 0, {weight: 4}); // update data for key=0\nG.addEdge(1, 3, {weight: 7, capacity: 15, length: 342.7});\n```"},{"name":"removeEdge","computed":false,"isAsync":false,"params":[{"name":"u","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node"},{"name":"v","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node"},{"name":"optKey","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"string"},{"type":"NameExpression","name":"number"}]},"typeAsHTML":"(string|number)","descr":"Used to distinguish multiple edges between\n  a pair of nodes. If undefined, remove a single (arbitrary) edge between\n  u and v."}],"description":"Remove an edge between u and v.\n\n### Example\n\n```\nvar G = new jsnx.MultiDiGraph();\nG.addPath([0,1,2,3]);\nG.removeEdge(0, 1);\n```\n\nFor multiple edges:\n\n```\nvar G = new jsnx.MultiDiGraph();\nG.addEdgesFrom([[1,2], [1,2], [1,2]]);\nG.removeEdge(1, 2); // remove a single (arbitrary) edge\n```\n\nFor edges with keys:\n\n```\nvar G = new jsnx.MultiDiGraph();\nG.addEdge(1, 2, 'first');\nG.addEdge(1, 2, 'second');\nG.removeEdge(1, 2, 'second');\n```"},{"name":"edgesIter","computed":false,"isAsync":false,"params":[{"name":"optNbunch","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","descr":"(default=all nodes) A container of nodes.\n  The container will be iterated over only once."},{"name":{"name":"optData"},"type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","descr":"(default=false) If true, return edge attribute\n  dictionaries with each edge.","defaultValue":"false"},{"name":{"name":"optKeys"},"type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","descr":"(default=flase) If true, return edge keys with\n  each edge.","defaultValue":"false"}],"description":"Return an iterator over the edges.\n\nEdges are returned as tuples with optional data and keys in the order\n`(node, neighbor, key, data)`.\n\n### Note\n\nNodes in `optNbunch` that are not in the graph will be (quietly) ignored.\nFor directed graphs this returns the out-edges.\n\n### Example\n\n```\nvar G = new jsnx.MultiDiGraph();\nG.addPath([0,1,2,3]);\nArray.from(G.edgesIter());\n// [[0,1], [1,2], [2,3]]\nArray.from(G.edgesIter(true));\n// [[0,1,{}], [1,2,{}], [2,3,{}]]\nArray.from(G.edgesIter([0,2]));\n// [[0,1], [2,3]]\n```","returns":{"name":"An","type":{"type":"NameExpression","name":"Iterator"},"typeAsHTML":"Iterator","descr":"iterator of `(u,v)`, `(u,v,d)` or `(u,v,key,d)` edges"}},{"name":"outEdgesIter","computed":false,"isAsync":false,"params":[{"name":"optNbunch"},{"name":"optData"},{"name":"optKeys"}],"description":""},{"name":"outEdges","computed":false,"isAsync":false,"params":[{"name":"optNbunch","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","descr":"(default=all nodes) A container of nodes.\n  The container will be iterated over only once."},{"name":"optData","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","descr":"(default=false) If true, return edge attribute\n  dictionaries with each edge."},{"name":"optKeys","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","descr":"(default=flase) If true, return edge keys with\n  each edge."}],"description":"Return a list of the outgoing edges.\n\nEdges are returned as tuples with optional data and keys in the order\n`(node, neighbor, key, data)`.\n\n### Note\n\nNodes in `optNbunch` that are not in the graph will be (quietly) ignored.\nFor directed graphs `edges()` is the same as `outEdges()`.","returns":{"name":"A","type":{"type":"NameExpression","name":"Array"},"typeAsHTML":"Array","descr":"list of `(u,v)`, `(u,v,d)` or `(u,v,key,d)` tuples of\n  edges"}},{"name":"inEdgesIter","computed":false,"isAsync":false,"params":[{"name":"optNbunch","type":{"type":"NameExpression","name":"Iterable","optional":true},"typeAsHTML":"Iterable=","descr":"(default=all nodes) A container of nodes.\n  The container will be iterated over only once."},{"name":{"name":"optData"},"type":{"type":"NameExpression","name":"boolean","optional":true},"typeAsHTML":"boolean=","descr":"(default=false) If true, return edge attribute\n  dictionaries with each edge.","defaultValue":"false"},{"name":{"name":"optKeys"},"type":{"type":"NameExpression","name":"boolean","optional":true},"typeAsHTML":"boolean=","descr":"(default=flase) If true, return edge keys with\n  each edge.","defaultValue":"false"}],"description":"Return an iterator over the incoming edges.\n\nEdges are returned as tuples with optional data and keys in the order\n`(node, neighbor, key, data)`.","returns":{"name":"An","type":{"type":"NameExpression","name":"Iterator"},"typeAsHTML":"Iterator","descr":"iterator of `(u,v)`, `(u,v,d)` or `(u,v,key,d)` edges"}},{"name":"inEdges","computed":false,"isAsync":false,"params":[{"name":"optNbunch","type":{"type":"NameExpression","name":"Iterable","optional":true},"typeAsHTML":"Iterable=","descr":"(default=all nodes) A container of nodes.\n  The container will be iterated over only once."},{"name":"optData","type":{"type":"NameExpression","name":"boolean","optional":true},"typeAsHTML":"boolean=","descr":"(default=false) If true, return edge attribute\n  dictionaries with each edge."},{"name":"optKeys","type":{"type":"NameExpression","name":"boolean","optional":true},"typeAsHTML":"boolean=","descr":"(default=flase) If true, return edge keys with\n  each edge."}],"description":"Return a list of the incoming edges.","returns":{"name":"A","type":{"type":"NameExpression","name":"Array"},"typeAsHTML":"Array","descr":"list of `(u,v)`, `(u,v,d)` or `(u,v,key,d)` tuples of\n  edges"}},{"name":"degreeIter","computed":false,"isAsync":false,"params":[{"name":"optNbunch","type":{"type":"NameExpression","name":"Iterable","optional":true},"typeAsHTML":"Iterable=","descr":"(default=all nodes) A container of nodes.\n  The container will be iterated through once."},{"name":"optWeight","type":{"type":"NameExpression","name":"string","optional":true},"typeAsHTML":"string=","descr":"(default=null)\n  The edge attribute that holds the numerical value used as a weight. If\n  None, then each edge has weight 1.\n  The degree is the sum of the edge weights."}],"description":"Return an iterator for `(node, degree)`.\n\nThe node degree is the number of edges adjacent to the node.\n\n### Example\n\n```\nvar G = new jsnx.MultiDiGraph();\nG.addPath([0,1,2,3]);\nArray.from(G.degreeIter([0,1]));\n// [[0,1], [1,2]]\n```","returns":{"name":"The","type":{"type":"NameExpression","name":"Iterator"},"typeAsHTML":"Iterator","descr":"iterator returns two-tuples of `(node, degree)`."}},{"name":"inDegreeIter","computed":false,"isAsync":false,"params":[{"name":"optNbunch","type":{"type":"NameExpression","name":"Iterable","optional":true},"typeAsHTML":"Iterable=","descr":"(default=all nodes) A container of nodes.\n  The container will be iterated through once."},{"name":"optWeight","type":{"type":"NameExpression","name":"string","optional":true},"typeAsHTML":"string=","descr":"(default=null)\n  The edge attribute that holds the numerical value used as a weight. If\n  None, then each edge has weight 1.\n  The degree is the sum of the edge weights."}],"description":"Return an iterator for `(node, in-degree)`.\n\nThe node in-degree is the number of edges pointing to the node.\n\n### Example\n\n```\nvar G = new jsnx.MultiDiGraph();\nG.addPath([0,1,2,3]);\nArray.from(G.degreeIter([0,1]));\n// [[0,0], [1,1]]\n```","returns":{"name":"The","type":{"type":"NameExpression","name":"Iterator"},"typeAsHTML":"Iterator","descr":"iterator returns two-tuples of `(node, degree)`."}},{"name":"outDegreeIter","computed":false,"isAsync":false,"params":[{"name":"optNbunch","type":{"type":"NameExpression","name":"Iterable","optional":true},"typeAsHTML":"Iterable=","descr":"(default=all nodes) A container of nodes.\n  The container will be iterated through once."},{"name":"optWeight","type":{"type":"NameExpression","name":"string","optional":true},"typeAsHTML":"string=","descr":"(default=null)\n  The edge attribute that holds the numerical value used as a weight. If\n  None, then each edge has weight 1.\n  The degree is the sum of the edge weights."}],"description":"Return an iterator for `(node, out-degree)`.\n\nThe node out-degree is the number of edges pointing out of the node.\n\n### Example\n\n```\nvar G = new jsnx.MultiDiGraph();\nG.addPath([0,1,2,3]);\nArray.from(G.degreeIter([0,1]));\n// [[0,1], [1,1]]\n```","returns":{"name":"The","type":{"type":"NameExpression","name":"Iterator"},"typeAsHTML":"Iterator","descr":"iterator returns two-tuples of `(node, degree)`."}},{"name":"isMultigraph","computed":false,"isAsync":false,"params":[],"description":"Return True if graph is a multigraph, False otherwise.","returns":{"name":"True","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","descr":"if graph is a multigraph, False otherwise."}},{"name":"isDirected","computed":false,"isAsync":false,"params":[],"description":"Return True if graph is directed, False otherwise.","returns":{"name":"True","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","descr":"if graph is directed, False otherwise."}},{"name":"toDirected","computed":false,"isAsync":false,"params":[],"description":"Return a directed copy of the graph.\n\n### Notes\n\nThis returns a deep copy of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references.\n\nThis is in contrast to the similar `var G = new MultiDiGraph(D);`, which\nreturns a shallow copy of the data.","returns":{"name":"A","type":{"type":"NameExpression","name":"MultiDiGraph"},"typeAsHTML":"MultiDiGraph","descr":"deep copy of the graph."}},{"name":"toUndirected","computed":false,"isAsync":false,"params":[{"name":"optReciprocal","type":{"type":"NameExpression","name":"boolean","optional":true},"typeAsHTML":"boolean=","descr":"If true, only keep edges that appear in\n  both directions in the original digraph."}],"description":"Return an undirected representation of the digraph.\n\n### Notes\n\nThe result is an undirected graph with the same name, nodes and\nwith edge `(u,v,data)` if either `(u,v,data)` or `(v,u,data)`\nis in the digraph.  If both edges exist in digraph and\ntheir edge data is different, only one edge is created\nwith an arbitrary choice of which edge data to use.\nYou must check and correct for this manually if desired.\n\nThis returns a deep copy of the edge, node, and\ngraph attributes which attempts to completely copy\nall of the data and references.\n\nThis is in contrast to the similar `var G = new MultiGraph(D);`, which\nreturns a shallow copy of the data.","returns":{"type":{"type":"NameExpression","name":"MultiGraph"},"typeAsHTML":"MultiGraph"}},{"name":"subgraph","computed":false,"isAsync":false,"params":[{"name":"nBunch","type":{"type":"NameExpression","name":"Iterable"},"typeAsHTML":"Iterable","descr":"A container of nodes which will be iterated\n  through once."}],"description":"Return the subgraph induced on nodes in `nbunch`.\n\nThe induced subgraph of the graph contains the nodes in `optNbunch` and the\nedges between those nodes.\n\n### Notes\n\nThe graph, edge or node attributes just point to the original graph.\nSo changes to the node or edge structure will not be reflected in\nthe original graph while changes to the attributes will.\n\nTo create a subgraph with its own copy of the edge/node attributes use:\n`jsnx.MultiDiGraph(G.subgraph(nbunch))`.\n\n### Example\n\n```\nvar G = new jsnx.MultiDiGraph();\nG.addPath([0,1,2,3]);\nvar H = G.subgraph([0,1,2]);\nH.edges();\n// [[0,1], [1,2]]\n```","returns":{"type":{"type":"NameExpression","name":"MultiDiGraph"},"typeAsHTML":"MultiDiGraph"}},{"name":"reverse","computed":false,"isAsync":false,"params":[{"name":{"name":"optCopy"},"type":{"type":"NameExpression","name":"boolean","optional":true},"typeAsHTML":"boolean=","descr":"If true, return a new MultiDiGraph holding the\n  reversed edges. If false, the reverse graph is created using the original\n  graph (this changes the original graph).","defaultValue":"true"}],"description":"Return the reverse of the graph.\n\nThe reverse is a graph with the same nodes and edges but with the\ndirections of the edges reversed.","returns":{"type":{"type":"NameExpression","name":"MultiDiGraph","nullable":true},"typeAsHTML":"?MultiDiGraph"}}],"properties":[],"staticMethods":[],"staticProperties":[{"name":"__name__","computed":false,"isAsync":false,"params":[],"description":"Holds the graph type (class) name for information.","readonly":true}],"constructor":{"name":"MultiDiGraph","computed":false,"isAsync":false,"params":[{"name":"optData","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Object"},{"type":"NameExpression","name":"Array"},{"type":"NameExpression","name":"Graph"}]},"typeAsHTML":"(Object|Array|Graph)","descr":"Data to initialize graph.\n  If no data is passed, an empty graph is created. The data can be an edge\n  list, or any JSNetworkX graph object."},{"name":"optAttr","type":{"type":"NameExpression","name":"Object","optional":true},"typeAsHTML":"Object=","descr":"(default= no attributes)\n      Attributes to add to graph as key=value pairs."}],"description":""}},"KeyError":{"name":"KeyError","aliases":["KeyError","exceptions.KeyError"],"isClass":true,"methods":[],"properties":[],"staticMethods":[],"staticProperties":[],"constructor":{"name":"KeyError","computed":false,"isAsync":false,"params":[{"name":"message"}]}},"JSNetworkXAlgorithmError":{"name":"JSNetworkXAlgorithmError","aliases":["JSNetworkXAlgorithmError","exceptions.JSNetworkXAlgorithmError"],"isClass":true,"description":"Exception for unexpected termination of algorithms.","extends":"JSNetworkXException","methods":[],"properties":[],"staticMethods":[],"staticProperties":[],"constructor":{"name":"JSNetworkXAlgorithmError","computed":false,"isAsync":false,"params":[{"name":"message"}]}},"JSNetworkXError":{"name":"JSNetworkXError","aliases":["JSNetworkXError","exceptions.JSNetworkXError"],"isClass":true,"methods":[],"properties":[],"staticMethods":[],"staticProperties":[],"constructor":{"name":"JSNetworkXError","computed":false,"isAsync":false,"params":[{"name":"message"}]}},"JSNetworkXException":{"name":"JSNetworkXException","aliases":["JSNetworkXException","exceptions.JSNetworkXException"],"isClass":true,"methods":[],"properties":[],"staticMethods":[],"staticProperties":[],"constructor":{"name":"JSNetworkXException","computed":false,"isAsync":false,"params":[{"name":"message"}]}},"JSNetworkXNoPath":{"name":"JSNetworkXNoPath","aliases":["JSNetworkXNoPath","exceptions.JSNetworkXNoPath"],"isClass":true,"description":"Exception for algorithms that should return a path when running\non graphs where such a path does not exist.","extends":"JSNetworkXUnfeasible","methods":[],"properties":[],"staticMethods":[],"staticProperties":[],"constructor":{"name":"JSNetworkXNoPath","computed":false,"isAsync":false,"params":[{"name":"message"}]}},"JSNetworkXUnfeasible":{"name":"JSNetworkXUnfeasible","aliases":["JSNetworkXUnfeasible","exceptions.JSNetworkXUnfeasible"],"isClass":true,"description":"Exception raised by algorithms trying to solve a problem\ninstance that has no feasible solution.","extends":"JSNetworkXAlgorithmError","methods":[],"properties":[],"staticMethods":[],"staticProperties":[],"constructor":{"name":"JSNetworkXUnfeasible","computed":false,"isAsync":false,"params":[{"name":"message"}]}}},"Misc":{"nodes":{"name":"nodes","aliases":["nodes","classes.nodes"],"isAsync":false,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"Graph"}],"description":"Return a copy of the graph nodes in a list.","returns":{"name":"List","type":{"type":"NameExpression","name":"Array"},"typeAsHTML":"Array","descr":"of nodes"}},"nodesIter":{"name":"nodesIter","aliases":["nodesIter","classes.nodesIter"],"isAsync":false,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"Graph"}],"description":"Return an iterator over the graph nodes.","returns":{"name":"Iterator","type":{"type":"NameExpression","name":"Iterator"},"typeAsHTML":"Iterator","descr":"over graph nodes"}},"edges":{"name":"edges","aliases":["edges","classes.edges"],"isAsync":false,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"Graph"},{"name":"optNbunch","type":{"type":"NameExpression","name":"NodeContainer","optional":true},"typeAsHTML":"NodeContainer=","descr":"Nodes"}],"description":"Return a list of edges adjacent to nodes in nbunch.\n\nReturn all edges if nbunch is unspecified or nbunch=None.\nFor digraphs, edges=out_edges","returns":{"name":"List","type":{"type":"NameExpression","name":"Array"},"typeAsHTML":"Array","descr":"of edges"}},"edgesIter":{"name":"edgesIter","aliases":["edgesIter","classes.edgesIter"],"isAsync":false,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"Graph"},{"name":"optNbunch","type":{"type":"NameExpression","name":"NodeContainer","optional":true},"typeAsHTML":"NodeContainer=","descr":"Nodes"}],"description":"Return iterator over  edges adjacent to nodes in nbunch.\n\nReturn all edges if nbunch is unspecified or nbunch=None.\nFor digraphs, edges=out_edges","returns":{"name":"Iterator","type":{"type":"NameExpression","name":"Iterator"},"typeAsHTML":"Iterator","descr":"over edges"}},"degree":{"name":"degree","aliases":["degree","classes.degree"],"isAsync":false,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"Graph"},{"name":"optNbunch","type":{"type":"NameExpression","name":"NodeContainer","optional":true},"typeAsHTML":"NodeContainer=","descr":"Nodes"},{"name":"optWeight","type":{"type":"NameExpression","name":"string","optional":true},"typeAsHTML":"string=","descr":"Weight attribute name"}],"description":"Return degree of single node or of nbunch of nodes.\nIf nbunch is omitted, then return degrees of *all* nodes.","returns":{"name":"Degree","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"number"},{"type":"NameExpression","name":"Map"}]},"typeAsHTML":"(number|Map)","descr":"of node(s)"}},"neighbors":{"name":"neighbors","aliases":["neighbors","classes.neighbors"],"isAsync":false,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"Graph"},{"name":"n","type":{"type":"NameExpression","name":"Node"},"typeAsHTML":"Node","descr":"Node"}],"description":"Return a list of nodes connected to node n.","returns":{"name":"List","type":{"type":"NameExpression","name":"Array"},"typeAsHTML":"Array","descr":"of nodes"}},"numberOfNodes":{"name":"numberOfNodes","aliases":["numberOfNodes","classes.numberOfNodes"],"isAsync":false,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"Graph"}],"description":"Return the number of nodes in the graph.","returns":{"name":"Number","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","descr":"of nodes"}},"numberOfEdges":{"name":"numberOfEdges","aliases":["numberOfEdges","classes.numberOfEdges"],"isAsync":false,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"Graph"}],"description":"Return the number of edges in the graph.","returns":{"name":"Number","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number","descr":"of edges"}},"density":{"name":"density","aliases":["density","classes.density"],"isAsync":false,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"Graph"}],"description":"Return the density of a graph.\nThe density for undirected graphs is\n\n```math\nd = \\frac{2m}{n(n-1)}\n```\n\nand for directed graphs is\n\n```math\n\\frac{m}{n(n-1)}\n```\n\nwhere n is the number of nodes and m is the number of edges in G\n\nThe density is 0 for an graph without edges and 1.0 for a complete graph.\nThe density of multigraphs can be higher than 1.","returns":{"name":"Density","type":{"type":"NameExpression","name":"number"},"typeAsHTML":"number"}},"degreeHistogram":{"name":"degreeHistogram","aliases":["degreeHistogram","classes.degreeHistogram"],"isAsync":false,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"Graph"}],"description":"Return a list of the frequency of each degree value.\n\nNote: the bins are width one, hence list.length can be large\n(Order(number_of_edges))\n","returns":{"name":"A","type":{"type":"NameExpression","name":"Array"},"typeAsHTML":"Array","descr":"list of frequencies of degrees.\n     The degree values are the index in the list."}},"isDirected":{"name":"isDirected","aliases":["isDirected","classes.isDirected"],"isAsync":false,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"Graph"}],"description":"Return True if graph is directed.","returns":{"name":"True","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","descr":"if graph is directed"}},"freeze":{"name":"freeze","aliases":["freeze","classes.freeze"],"isAsync":false,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"Graph"}],"description":"Modify graph to prevent addition of nodes or edges.\n\nThis does not prevent modification of edge data.\nTo \"unfreeze\" a graph you must make a copy.","returns":{"name":"A","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"reference to the input graph"}},"isFrozen":{"name":"isFrozen","aliases":["isFrozen","classes.isFrozen"],"isAsync":false,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"Graph"}],"description":"Return True if graph is frozen.","returns":{"name":"True","type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","descr":"if graph is frozen."}},"subgraph":{"name":"subgraph","aliases":["subgraph","classes.subgraph"],"isAsync":false,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"Graph"},{"name":"nbunch","type":{"type":"NameExpression","name":"NodeContainer"},"typeAsHTML":"NodeContainer","descr":"A container of nodes that will be iterated through once (thus\n     it should be an iterator or be iterable).  Each element of the\n     container should be a valid node type: any hashable type except\n     None.  If nbunch is None, return all edges data in the graph.\n     Nodes in nbunch that are not in the graph will be (quietly)\n     ignored."}],"description":"Return the subgraph induced on nodes in nbunch.\n\nNote:  subgraph(G) calls G.subgraph()","returns":{"name":"Subgraph","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}},"createEmptyCopy":{"name":"createEmptyCopy","aliases":["createEmptyCopy","classes.createEmptyCopy"],"isAsync":false,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"Graph"},{"name":{"name":"optWithNodes"},"type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean","descr":"(default=True)\n     Include nodes.","defaultValue":"true"}],"description":"Return a copy of the graph G with all of the edges removed.\n\nNotes: Graph, node, and edge data is not propagated to the new graph.","returns":{"name":"A","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"copy of the graph"}},"info":{"name":"info","aliases":["info","classes.info"],"isAsync":false,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"Graph"},{"name":"optN","type":{"type":"NameExpression","name":"Node","optional":true},"typeAsHTML":"Node=","descr":"A node in the graph G"}],"description":"Print short summary of information for the graph G or the node n.","returns":{"name":"Info","type":{"type":"NameExpression","name":"string"},"typeAsHTML":"string"}},"setNodeAttributes":{"name":"setNodeAttributes","aliases":["setNodeAttributes","classes.setNodeAttributes"],"isAsync":false,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"Graph"},{"name":"name","type":{"type":"NameExpression","name":"string"},"typeAsHTML":"string","descr":"Attribute name"},{"name":"attributes","type":{"type":"TypeUnion","elements":[{"type":"NameExpression","name":"Object"},{"type":"NameExpression","name":"Map"}]},"typeAsHTML":"(Object|Map)","descr":"Dictionary of attributes keyed by node"}],"description":"Set node attributes from dictionary of nodes and values"},"getNodeAttributes":{"name":"getNodeAttributes","aliases":["getNodeAttributes","classes.getNodeAttributes"],"isAsync":false,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"Graph"},{"name":"name","type":{"type":"NameExpression","name":"string"},"typeAsHTML":"string","descr":"Attribute name"}],"description":"Get node attributes from graph","returns":{"name":"Dictionary","type":{"type":"NameExpression","name":"Map","nullable":false},"typeAsHTML":"!Map","descr":"of attributes keyed by node."}},"setEdgeAttributes":{"name":"setEdgeAttributes","aliases":["setEdgeAttributes","classes.setEdgeAttributes"],"isAsync":false,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"Graph"},{"name":"name","type":{"type":"NameExpression","name":"string"},"typeAsHTML":"string","descr":"Attribute name"},{"name":"attributes","type":{"type":"NameExpression","name":"Map"},"typeAsHTML":"Map","descr":"Dictionary of attributes keyed by edge (tuple)."}],"description":"Set edge attributes from dictionary of edge tuples and values"},"getEdgeAttributes":{"name":"getEdgeAttributes","aliases":["getEdgeAttributes","classes.getEdgeAttributes"],"isAsync":false,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"Graph"},{"name":"name","type":{"type":"NameExpression","name":"string"},"typeAsHTML":"string","descr":"Attribute name"}],"description":"Get edge attributes from graph\n\nSince keys can only be strings in JavaScript, the edge is returned as\n{@code \"node1,node2\"} string. You'd have to call {@code .split(',')} on\nthe keys to extract the actual node names.","returns":{"name":"Dictionary","type":{"type":"NameExpression","name":"Map","nullable":false},"typeAsHTML":"!Map","descr":"of attributes keyed by edge."}},"draw":{"name":"draw","aliases":["draw","drawing.draw"],"isAsync":false,"params":[{"name":"G","type":{"type":"NameExpression","name":"jsnx.classes.Graph"},"typeAsHTML":"jsnx.classes.Graph","descr":"The graph to draw"},{"name":"config","type":{"type":"NameExpression","name":"Object","optional":true,"nullable":true},"typeAsHTML":"?Object=","descr":"A dictionary of configuration parameters."},{"name":"optBind","type":{"type":"NameExpression","name":"boolean","optional":true,"nullable":true},"typeAsHTML":"?boolean=","descr":"Set to true to automatically update\n     the output upon graph manipulation. Only works for adding nodes or edges\n     for now."}],"description":"Draw graph G with D3.\n\nThis method draws `G` with the provided `options`. If `optBind` is set to\n`true`, changes to the graph structure will automatically update the\nvisualization.\n\nReturns the force layout used to compute the position of the nodes.\n\nThe following options are available:\n\n- element (Element|String): This option is **required**. Specifies the\n  container of the visualization. A string is interpreted as CSS selector.\n- d3 (d3): Use to explicitly pass a reference to D3. If not present, the\n  global variable d3 will be used instead.\n- width (number): The width of the canvas in pixels. Defaults to the width\n  of the container.\n- height (number): The height of the canvas in pixels. Defaults to the\n  height of the container.\n- layoutAttr (Object): Layout options. The default layout is \"force\", so\n  the options size, linkDistance, linkStrength, friction, charge, theta\n  and gravity can be set. For example, setting `{linkDistance: 10}` will call\n  `force.linkDistance(10)`.\n- nodelist (Iterable): An iterable of nodes. If present, only nodes in that\n  list will be drawn.\n- nodeShape (string): The tag name of the SVG element to be used as nodes.\n  Defaults to \"circle\".\n- nodeAttr (Object): The attributes to set on the node SVG element. This\n  object is passed along to D3's `.attr()` method.\n- nodeStyle (Object): The style properties to set on the node SVG element.\n  This object is passed along to D3's `.style()` method.\n- edgeAttr (Object): The attributes to set on an edge SVG element. Edges are\n  represented by SVG path elements.\n- edgeStyle (Object): The style properties to set on the edge SVG element.\n  Note: Even though the edge element is a SVG path element, you cannot set\n  `stroke-width` to set the stroke width. Instead, the value of\n  `stroke-width` is used as maximum value for the edge width.\n- withLabels (boolean): Whether or not to draw node labels. SVG text elements\n  are used for labels.\n- labels (string|Object|function): The node labels to use.\n  If `withLabels` is `true`, but `labels` is not present, defaults to the\n  node itself.\n  If a string is passed, the value of the property of the node data with the\n  same name will be used.\n  If an object is passed, the label is looked up in the object using the node\n  as property name.\n  If a function is passed, it gets called and passed the corresponding D3\n  data object.\n- labelAttr (Object): Like `nodeAttr` but for the label nodes. Labels are\n  represented by SVG text nodes.\n- labelStyle (Object): Like `nodeStyle` but for the label nodes. Labels are\n  represented by SVG text nodes.\n- withEdgeLabels (boolean): See `withLabels`, but for edges.\n- edgeLabels (string|Object|function): See `labels`.\n- edgeLabelAttr (Object): Like `labelAttr`.\n- edgeLabelStyle (Object): Like `labelStyle`.\n- weighted (boolean): Whether the edge width depends on the weight of the\n  edge. The max and min weight are automatically computed. This is a\n  convenience option so that you don't have to compute the edge weights\n  yourself.\n- weights (string|function): Specifies the weight for each edge.\n  If `weighted` is `true` but `weights` is not present, defaults to\n  `\"weight\"`.\n  If a string is passed, the value of the property of the edge data with the\n  same name is used as weight.\n  If a function is passed, it gets called and passed the corresponding D3\n  data object.\n- edgeOffset (number|function): The distance in pixels between the edge start\n  and the node. If not set and `nodeShape` is a `\"circle\"`, the offset will\n  be automatically computed based on the radius.\n  If a different shape for nodes is used it might be necessary to set the\n  offset manually.\n- edgeLabelOffset (number|function): By default edge labels are drawing in\n  in the center of the edge. Can be used to adjust the position.\n- panZoom (Object):\n     - enabled (boolean): Enables panning and zooming of the canvas.\n     - scale (boolean): Whether nodes and labels should keep their size\n       when zooming or not.","returns":{"type":{"type":"NameExpression","name":"d3.layout.force"},"typeAsHTML":"d3.layout.force"}},"observe":{"aliases":["observe"],"name":"observe","isAsync":false,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"The graph to make observable"}],"description":"Makes a graph observable, i.e. external code can bind event handlers to\nbe notified about changes in the graph (adding or removing nodes or edges).","returns":{"name":"The","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"same graph passed as argument (not a new graph)"}},"unobserve":{"aliases":["unobserve"],"name":"unobserve","isAsync":false,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}],"description":"Removes the properties added to a graph for event handling.","returns":{"name":"The","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph","descr":"graph passed to the function"}},"isObservable":{"aliases":["isObservable"],"name":"isObservable","isAsync":false,"params":[{"name":"G","type":{"type":"NameExpression","name":"Graph"},"typeAsHTML":"Graph"}],"description":"Tests whether the graph is observable.","returns":{"type":{"type":"NameExpression","name":"boolean"},"typeAsHTML":"boolean"}},"toNetworkxGraph":{"name":"toNetworkxGraph","aliases":["toNetworkxGraph","default.toNetworkxGraph"]},"convertToUndirected":{"name":"convertToUndirected","aliases":["convertToUndirected","default.convertToUndirected"]},"convertToDirected":{"name":"convertToDirected","aliases":["convertToDirected","default.convertToDirected"]},"toDictOfLists":{"name":"toDictOfLists","aliases":["toDictOfLists","default.toDictOfLists"]},"fromDictOfLists":{"name":"fromDictOfLists","aliases":["fromDictOfLists","default.fromDictOfLists"]},"toDictOfDicts":{"name":"toDictOfDicts","aliases":["toDictOfDicts","default.toDictOfDicts"]},"fromDictOfDicts":{"name":"fromDictOfDicts","aliases":["fromDictOfDicts","default.fromDictOfDicts"]},"toEdgelist":{"name":"toEdgelist","aliases":["toEdgelist","default.toEdgelist"]},"fromEdgelist":{"name":"fromEdgelist","aliases":["fromEdgelist","default.fromEdgelist"]},"relabelNodes":{"aliases":["relabelNodes"]},"convertNodeLabelsToIntegers":{"aliases":["convertNodeLabelsToIntegers"]}}}